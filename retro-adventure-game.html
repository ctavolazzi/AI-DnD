<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI D&D - The Emberpeak Expedition</title>
    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Ctext y='50'%20font-size='48'%3E%F0%9F%8F%9B%EF%B8%8F%3C/text%3E%3C/svg%3E">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        /* ============================================
           THEME DEFINITIONS - All theme colors here
           ============================================

           To add a new theme:
           1. Copy any [data-theme="name"] block below
           2. Change the theme name (e.g., [data-theme="forest"])
           3. Update all color values to match your theme
           4. Add the theme to THEMES object in JavaScript:
              forest: 'Forest Green'
           5. Done! No other changes needed.

           CSS Variables Reference:
           - --bg-deep-brown: Main background color
           - --bg-darker-brown: Darker background for depth
           - --panel-parchment: Panel/card backgrounds
           - --panel-parchment-dark: Darker panel variant
           - --border-wood: Primary border color
           - --border-bronze: Accent border/frame color
           - --primary-gold: Primary text highlight color
           - --accent-amber: Secondary accent color
           - --text-dark: Dark text (on light backgrounds)
           - --text-light: Light text (on dark backgrounds)
           - --text-cream: Medium contrast text
           - --accent-brown: Brown accent color
           - --alert-rust: Warning/alert color
           - --hp-green: HP bar color (high health)
           - --hp-yellow: HP bar color (medium health)
           - --hp-red: HP bar color (low health)
           - --stat-blue: Statistics display color
           - --quest-complete: Completion indicator color
           ============================================ */

        /* Default Theme: Retro RPG */
        :root {
            --bg-deep-brown: #1a1410;        /* Dark brown background */
            --bg-darker-brown: #0f0a08;      /* Even darker brown */
            --panel-parchment: #e8d4b8;      /* Light cream panels */
            --panel-parchment-dark: #d4c4a8; /* Slightly darker cream */
            --border-wood: #4a3426;          /* Brown borders */
            --border-bronze: #b8860b;        /* Gold/bronze accents */
            --primary-gold: #ffd700;         /* Bright gold text */
            --accent-amber: #ffb347;         /* Orange highlights */
            --text-dark: #2a1810;            /* Dark brown text */
            --text-light: #f4e4c8;           /* Light cream text */
            --text-cream: #e8d4b8;           /* Medium cream */
            --accent-brown: #8b4513;         /* Medium brown */
            --alert-rust: #cd5c5c;           /* Red for alerts */
            --hp-green: #7cfc00;             /* Bright green (full HP) */
            --hp-yellow: #ffd700;            /* Gold (mid HP) */
            --hp-red: #dc143c;               /* Red (low HP) */
            --stat-blue: #4169e1;            /* Royal blue for stats */
            --quest-complete: #32cd32;       /* Lime green for completed */

            /* Spacing System */
            --space-xs: 4px;   /* Tiny gaps */
            --space-sm: 8px;   /* Small gaps */
            --space-md: 12px;  /* Medium (default) */
            --space-lg: 16px;  /* Large gaps */
            --space-xl: 20px;  /* Extra large */
        }

        /* Theme: Ultima Fantasy - Warm Brown/Parchment */
        [data-theme="ultima"] {
            --bg-deep-brown: #2a1810;
            --bg-darker-brown: #1a0f08;
            --panel-parchment: #d4b896;
            --panel-parchment-dark: #c4a886;
            --border-wood: #4a3426;
            --border-bronze: #8b6f47;
            --primary-gold: #c9941a;
            --accent-amber: #d4a82a;
            --text-dark: #2a1810;
            --text-light: #f4e4c8;
            --text-cream: #e8d4b8;
            --accent-brown: #8b4513;
            --alert-rust: #a0522d;
            --hp-green: #6b8e23;
            --hp-yellow: #daa520;
            --hp-red: #8b2500;
        }

        /* Theme: Cyber Terminal - Neon Green Cyberpunk */
        [data-theme="cyber"] {
            --bg-deep-brown: #000;
            --bg-darker-brown: #0a0e0a;
            --panel-parchment: #001a00;
            --panel-parchment-dark: #001100;
            --border-wood: #0a0;
            --border-bronze: #0f0;
            --primary-gold: #0ff;
            --accent-amber: #ff0;
            --text-dark: #0f0;
            --text-light: #0f0;
            --text-cream: #0f0;
            --accent-brown: #0a0;
            --alert-rust: #f00;
            --hp-green: #0f0;
            --hp-yellow: #ff0;
            --hp-red: #f00;
        }

        /* Theme: Gold Box - Royal Blue & Gold */
        [data-theme="goldbox"] {
            --bg-deep-brown: #001133;
            --bg-darker-brown: #000822;
            --panel-parchment: #2a3a5a;
            --panel-parchment-dark: #1a2a4a;
            --border-wood: #8b7355;
            --border-bronze: #d4af37;
            --primary-gold: #ffd700;
            --accent-amber: #ffec8b;
            --text-dark: #1a1a2e;
            --text-light: #e8e8ff;
            --text-cream: #d4d4e8;
            --accent-brown: #8b7355;
            --alert-rust: #b8860b;
            --hp-green: #4a7c59;
            --hp-yellow: #d4af37;
            --hp-red: #8b2500;
        }

        /* Theme: Dark Dungeon - Dark Charcoal & Torchlight */
        [data-theme="dungeon"] {
            --bg-deep-brown: #0a0a0a;
            --bg-darker-brown: #050505;
            --panel-parchment: #1a1a1a;
            --panel-parchment-dark: #121212;
            --border-wood: #2a2a2a;
            --border-bronze: #3a3a3a;
            --primary-gold: #ff8c00;
            --accent-amber: #ffaa33;
            --text-dark: #666;
            --text-light: #d4a574;
            --text-cream: #c49564;
            --accent-brown: #8b4513;
            --alert-rust: #ff6347;
            --hp-green: #556b2f;
            --hp-yellow: #daa520;
            --hp-red: #8b0000;
        }

        /* ============================================
           COMPONENT STYLES - Uses theme variables
           ============================================ */

        * { margin: 0; padding: 0; box-sizing: border-box; }

        @keyframes scanline {
            0% { transform: translateY(-100%); }
            100% { transform: translateY(100%); }
        }

        @keyframes flicker {
            0%, 100% { opacity: 1; }
            50% { opacity: 1; }
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        body {
            font-family: 'Press Start 2P', 'VT323', 'Courier New', monospace;
            background: var(--bg-deep-brown);
            color: var(--text-light);
            overflow: hidden;
            height: 100vh;
            position: relative;
            font-size: 12px;
            line-height: 1.6;
        }

        /* No texture needed for pure monochrome */
        body::before {
            display: none;
        }

        .game-container {
            display: grid;
            grid-template-columns: 70fr 30fr;  /* 70% main area, 30% sidebar */
            grid-template-rows: 70px 1fr auto;  /* Header, content area, actions */
            gap: 16px;  /* Increased from 12px for better spacing */
            padding: 10px;
            height: 100vh;
            background: var(--bg-deep-brown);
            background-image:
                repeating-linear-gradient(0deg, transparent, transparent 2px,
                rgba(0,0,0,.1) 2px, rgba(0,0,0,.1) 4px);
            overflow: auto;  /* hidden → auto to allow scroll if needed */
        }

        .panel {
            background: var(--panel-parchment);
            border: 4px double var(--border-bronze);
            border-radius: 8px;
            padding: 12px;
            position: relative;
            box-shadow:
                inset 0 0 0 1px var(--border-wood),
                0 4px 8px rgba(0, 0, 0, 0.6),
                inset 0 2px 4px rgba(255, 215, 0, 0.2);
        }

        .panel-title {
            font-size: 11px;
            font-weight: bold;
            text-align: center;
            margin: -12px -12px 10px -12px;
            padding: 8px;
            background: linear-gradient(180deg, var(--border-bronze), var(--accent-brown));
            color: var(--text-light);
            border-bottom: 3px solid var(--border-wood);
            text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.7);
            letter-spacing: 2px;
            border-radius: 4px 4px 0 0;
        }

        /* Header */
        .header {
            grid-column: 1 / -1;
            text-align: center;
        }

        .game-title {
            font-size: 28px;
            color: #000;
            letter-spacing: 4px;
            margin-bottom: 5px;
        }

        .subtitle {
            color: #000;
            font-size: 12px;
            letter-spacing: 2px;
        }

        /* Theme Switcher Button */
        .theme-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: var(--panel-parchment);
            border: 2px solid var(--border-bronze);
            border-radius: 6px;
            padding: 8px 12px;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow:
                inset 0 1px 2px rgba(255, 255, 255, 0.3),
                0 2px 4px rgba(0, 0, 0, 0.4);
            z-index: 100;
        }

        .theme-btn:hover {
            background: var(--panel-parchment-dark);
            transform: translateY(-2px);
            box-shadow:
                inset 0 1px 2px rgba(255, 255, 255, 0.3),
                0 4px 8px rgba(0, 0, 0, 0.5);
        }

        .theme-btn:active {
            transform: translateY(0);
            box-shadow:
                inset 0 2px 4px rgba(0, 0, 0, 0.3),
                0 1px 2px rgba(0, 0, 0, 0.3);
        }

        /* Main area - left side (70%) */
        .main-area {
            grid-column: 1;
            grid-row: 2;
            display: flex;
            flex-direction: column;
            gap: 12px;
            min-height: 400px;  /* Ensure content area is always visible */
            overflow: auto;  /* Changed from hidden to auto for scrolling */
        }

        /* Main viewport - adventure log */
        .viewport-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 300px;  /* Ensure adventure log is always visible */
            overflow: visible;  /* Changed from hidden to visible */
        }

        /* Current Location Indicator */
        .current-location-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: linear-gradient(180deg, var(--primary-gold), var(--accent-amber));
            border: 2px solid var(--border-bronze);
            border-radius: 4px;
            margin-bottom: 8px;
            margin-right: 8px;  /* Prevent overlap with sidebar */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .location-icon {
            font-size: 16px;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .location-name {
            font-size: 13px;
            font-weight: bold;
            color: var(--text-dark);
            text-shadow: 1px 1px 0 rgba(255, 255, 255, 0.5);
        }

        /* System Console - spans middle column, row 3 */
        .system-console-container {
            grid-column: 2;
            grid-row: 3;
            display: flex;
            flex-direction: column;
            min-height: 0;
            overflow: hidden;
        }

        /* Scene Viewer - inside right sidebar */
        .scene-viewer-panel {
            display: flex;
            flex-direction: column;
            min-height: 120px;
            max-height: 180px;
            overflow: hidden;
        }

        .scene-viewer-content {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--panel-parchment);
            border: 3px solid var(--border-wood);  /* Hard pixel border, no glow */
            border-radius: 0;  /* Sharp corners for pixel-art aesthetic */
            padding: 8px;
            min-height: 0;
            overflow: hidden;
            position: relative;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);  /* Subtle depth, no glow */
        }

        .scene-image {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            border: 3px solid var(--border-wood);  /* Hard pixel border */
            display: none;
        }

        .scene-image.loaded {
            display: block;
            animation: fadeIn 0.5s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .scene-loading {
            color: #000;
            font-size: 14px;
            text-align: center;
            display: none;
        }

        .scene-loading.active {
            display: block;
        }

        .scene-loading::after {
            content: '';
            animation: ellipsis 1.5s infinite;
        }

        @keyframes ellipsis {
            0% { content: ''; }
            25% { content: '.'; }
            50% { content: '..'; }
            75% { content: '...'; }
            100% { content: ''; }
        }

        .scene-error {
            color: #000;
            font-size: 10px;
            text-align: center;
            display: none;
            font-style: italic;
            opacity: 1;
        }

        .scene-error.active {
            display: block;
        }

        .scene-fallback {
            color: #000;
            font-size: 10px;
            line-height: 1.2;
            white-space: pre;
            font-family: monospace;
        }

        .viewport {
            flex: 1;
            background: var(--panel-parchment);
            border: 3px solid var(--border-wood);
            border-radius: 4px;
            padding: 12px;
            font-family: 'Courier New', 'Consolas', monospace;  /* More readable font for body text */
            font-size: 14px;  /* Slightly larger for better readability */
            line-height: 1.7;  /* More breathing room */
            overflow-y: auto;
            position: relative;
            min-height: 0;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        /* System Console - terminal style */
        .system-console {
            flex: 1;
            background: #0a0e0a;  /* Dark terminal background */
            border: 3px solid var(--border-wood);
            border-radius: 4px;
            padding: 12px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            line-height: 1.4;
            overflow-y: auto;
            position: relative;
            min-height: 0;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.4);
            color: #0f0;  /* Green terminal text */
        }

        .viewport::-webkit-scrollbar {
            width: 8px;
        }

        .viewport::-webkit-scrollbar-track {
            background: var(--panel-parchment-dark);
        }

        .viewport::-webkit-scrollbar-thumb {
            background: var(--border-bronze);
            border-radius: 4px;
            border: 1px solid var(--border-wood);
        }

        .viewport::-webkit-scrollbar-thumb:hover {
            background: var(--primary-gold);
        }

        /* System Console Scrollbar */
        .system-console::-webkit-scrollbar {
            width: 8px;
        }

        .system-console::-webkit-scrollbar-track {
            background: #050805;
        }

        .system-console::-webkit-scrollbar-thumb {
            background: #0f0;
            border-radius: 4px;
        }

        .system-console::-webkit-scrollbar-thumb:hover {
            background: #0c0;
        }

        .text-line {
            margin-bottom: 8px;
            color: var(--text-dark);
            font-size: 13px;
            line-height: 1.5;
        }

        .text-line.combat {
            color: var(--accent-amber);
            font-weight: bold;
        }

        .text-line.damage {
            color: var(--alert-rust);
            font-weight: bold;
        }

        .text-line.success {
            color: var(--quest-complete);
        }

        .text-line.quest {
            color: var(--stat-blue);
            font-weight: bold;
        }

        .cursor::after {
            content: "█";
            animation: blink 1s infinite;
        }

        /* Right sidebar - 30% width */
        .right-sidebar {
            grid-column: 2;
            grid-row: 2;
            display: flex;
            flex-direction: column;
            gap: 12px;
            min-height: 0;
            overflow: hidden;
        }

        /* Character panel - inside right sidebar */
        .character-panel {
            flex: 1;
            min-height: 0;
            overflow-y: auto;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 80px 1fr;  /* auto → 80px for consistent label width */
            gap: var(--space-md);  /* 8px → 12px */
            font-size: 13px;
        }

        .stat-label {
            color: var(--stat-blue);
            font-weight: bold;
            text-shadow: 1px 1px 0 rgba(0, 0, 0, 0.5);
        }

        .stat-value {
            color: var(--primary-gold);
            text-align: right;
            font-weight: bold;
            background: rgba(26, 20, 16, 0.3);
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid var(--border-wood);
        }

        .hp-bar-container {
            grid-column: 1 / -1;
            background: var(--panel-parchment-dark);
            border: 2px solid var(--border-wood);
            height: 24px;
            margin-top: 5px;
            position: relative;
            overflow: hidden;
        }

        .hp-bar {
            height: 100%;
            background: linear-gradient(90deg,
                var(--hp-green) 0%,
                var(--hp-yellow) 50%,
                var(--hp-red) 100%);
            border: 2px solid var(--border-wood);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.4);
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            color: var(--text-dark);
            font-weight: bold;
            text-shadow: 1px 1px 0 rgba(255, 255, 255, 0.5);
        }

        .hp-bar.low {
            background: linear-gradient(90deg,
                var(--hp-yellow) 0%,
                var(--hp-red) 100%);
        }

        .hp-bar.critical {
            background: var(--hp-red);
            animation: blink 0.5s infinite;
        }

        /* Tabbed panel - bottom of sidebar */
        .tabbed-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
            overflow: hidden;
        }

        .tab-buttons {
            display: flex;
            gap: 4px;
            margin-bottom: 8px;
        }

        .tab-button {
            flex: 1;
            background: linear-gradient(180deg, var(--panel-parchment), var(--panel-parchment-dark));
            border: 3px solid var(--border-wood);
            color: var(--text-dark);
            font-family: 'Press Start 2P', monospace;
            font-size: 9px;
            padding: 8px 4px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
            position: relative;
        }

        .tab-button .tab-badge {
            position: absolute;
            top: -8px;
            right: -8px;
            background: var(--alert-rust);
            color: var(--text-light);
            font-size: 8px;
            padding: 2px 6px;
            border: 2px solid var(--border-wood);
            border-radius: 0;
            min-width: 18px;
            text-align: center;
            box-shadow: 2px 2px 0 rgba(0, 0, 0, 0.3);
        }

        .tab-button .tab-hint {
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 7px;
            color: var(--accent-brown);
            opacity: 0;
            white-space: nowrap;
            transition: opacity 0.2s;
            pointer-events: none;
        }

        .tab-button:hover .tab-hint {
            opacity: 0.8;
        }

        .tab-button:hover {
            background: linear-gradient(180deg, var(--primary-gold), var(--accent-amber));
            transform: translateY(-2px);
        }

        .tab-button.active {
            background: linear-gradient(180deg, var(--border-bronze), var(--accent-brown));
            color: var(--text-light);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
            border-color: var(--primary-gold);
            border-bottom: 4px solid var(--primary-gold);  /* Hard pixel border, no glow */
            transform: translateY(0px);
        }

        .tab-button.active::before {
            content: '▼';
            position: absolute;
            bottom: -14px;
            left: 50%;
            transform: translateX(-50%);
            color: var(--primary-gold);
            font-size: 10px;
            text-shadow: 1px 1px 0 rgba(0, 0, 0, 0.5);  /* Hard shadow, not glow */
        }

        .tab-content {
            flex: 1;
            display: none;
            min-height: 0;
            overflow: auto;
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
        }

        .tab-content.active {
            display: flex;
            flex-direction: column;
            animation: fadeIn 0.2s ease-in-out forwards;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(5px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Quest panel - inside tabbed panel */
        .quest-panel {
            display: flex;
            flex-direction: column;
            min-height: 0;
            overflow: visible;
        }

        .quest-objectives {
            font-size: 12px;
            line-height: 1.6;
            overflow-y: auto;
            max-height: 160px;
        }

        .objective {
            padding: 10px;  /* 8px → 10px for better breathing room */
            margin: var(--space-sm) 0;  /* 6px → 8px, use spacing variable */
            background: var(--panel-parchment-dark);
            border-left: 4px solid var(--border-bronze);
            border-radius: 4px;
            color: var(--text-dark);
        }

        .objective:last-child {
            margin-bottom: 0;  /* Remove margin on last item */
        }

        .objective::before {
            content: '☐';
            color: var(--accent-brown);
            margin-right: 8px;
            font-size: 14px;
            left: 0;
            color: #000;
        }

        .objective.completed {
            background: rgba(50, 205, 50, 0.2);
            border-left-color: var(--quest-complete);
            text-decoration: line-through;
            opacity: 0.8;
        }

        .objective.completed::before {
            content: '☑';
            color: var(--quest-complete);
        }

        /* Map panel */
        .map-panel {
            display: grid;
            grid-template-columns: 1fr 220px; /* Map + legend */
            gap: 12px;
            align-items: start;
            min-height: 0;
            overflow: visible;
        }

        .map-display {
            background: #fff;
            border: 2px solid #000;
            padding: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            height: auto;
        }

        .map-grid {
            display: grid;
            /* Responsive square cells using auto-fit with min() to cap size */
            grid-template-columns: repeat(7, minmax(28px, 1fr));
            gap: 2px;
            padding: var(--space-xs);
            border: 2px solid #000;
            width: 100%;
            max-width: 560px; /* keep reasonable width in narrow layouts */
            aspect-ratio: 7 / 5; /* keep 7x5 grid proportion */
        }

        /* Center map sizing without affecting modal */
        .center-map .map-display { min-height: 240px; }

        .map-cell {
            background: #3a2a1a;
            border: 1px solid var(--border-wood);  /* Kept at 1px - good size with gaps */
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 9px;
            position: relative;
            cursor: pointer;
            transition: all 0.2s;
        }

        /* Interactive states for neighbors */
        .map-cell.neighbor { outline: 2px dashed #6a9a6a; outline-offset: -2px; }
        .map-cell.neighbor:hover { outline-color: #9acc9a; }

        /* Fog of war - unexplored (NAVIGABLE - show with green tint) */
        .map-cell.unexplored {
            background: linear-gradient(135deg, #3a2a1a, #3d3020);
            border: 2px solid #5a7a5a;  /* Green tint to show navigability */
            box-shadow: inset 0 0 8px rgba(90, 122, 90, 0.3);
        }

        .map-cell.unexplored::after {
            content: "?";
            color: #7a9a7a;  /* Light green */
            font-size: 16px;
            font-weight: bold;
            text-shadow: 0 0 4px rgba(90, 122, 90, 0.8);
        }

        .map-cell.unexplored:hover {
            border-color: #6a9a6a;
            box-shadow: inset 0 0 12px rgba(90, 122, 90, 0.5);
        }

        /* Scouted locations (seen but not visited) */
        .map-cell.scouted {
            background: #5a4a3a;
            border-color: var(--accent-brown);
            opacity: 1;
        }

        .map-cell.scouted::before {
            content: attr(data-icon);
            position: absolute;
            font-size: 14px;
            opacity: 0.7;
        }

        /* Visited locations */
        .map-cell.visited {
            background: linear-gradient(135deg, #8b7355, #a0826d);
            border-color: var(--border-bronze);
        }

        .map-cell.visited::before {
            content: attr(data-icon);
            position: absolute;
            font-size: 16px;
            opacity: 1;
        }

        /* Underground locations - Enhanced for clarity */
        .map-cell.underground {
            background: #2a1a10;
            border-color: var(--border-wood);
        }

        .map-cell.underground.unexplored {
            background: linear-gradient(135deg, #2a1a10, #2d1d15);
            border: 2px solid #4a5a6a;  /* Blue-gray tint for underground */
            box-shadow: inset 0 0 8px rgba(74, 90, 106, 0.3);
        }

        .map-cell.underground.unexplored::after {
            color: #6a8a9a;  /* Light blue-gray */
            text-shadow: 0 0 4px rgba(74, 90, 106, 0.8);
        }

        .map-cell.underground.unexplored:hover {
            border-color: #5a7a8a;
            box-shadow: inset 0 0 12px rgba(74, 90, 106, 0.5);
        }

        .map-cell.underground.visited {
            background: linear-gradient(135deg, #6b5345, #7a6255);
            border-color: var(--border-bronze);
        }

        .map-cell.underground.scouted {
            background: #4a3a2a;
            border-color: var(--accent-brown);
        }

        .map-cell.underground.current {
            background: var(--primary-gold);
            color: var(--text-dark);
            border-color: var(--primary-gold);
            box-shadow: 0 0 8px var(--primary-gold);
        }

        /* Current position */
        .map-cell.current {
            background: var(--primary-gold);
            color: var(--text-dark);
            border-color: var(--primary-gold);
            box-shadow: 0 0 8px var(--primary-gold);
        }

        .map-cell.current::before {
            content: "👤";
            font-size: 18px;
            opacity: 1;
            filter: brightness(1.5);
        }

        /* Walls/Blocked paths - ENHANCED for visibility */
        .map-cell.wall-north {
            border-top: 6px solid #000;
            box-shadow: inset 0 4px 6px rgba(220, 20, 60, 0.4);
        }

        .map-cell.wall-south {
            border-bottom: 6px solid #000;
            box-shadow: inset 0 -4px 6px rgba(220, 20, 60, 0.4);
        }

        .map-cell.wall-east {
            border-right: 6px solid #000;
            box-shadow: inset -4px 0 6px rgba(220, 20, 60, 0.4);
        }

        .map-cell.wall-west {
            border-left: 6px solid #000;
            box-shadow: inset 4px 0 6px rgba(220, 20, 60, 0.4);
        }

        /* Directional indicators for walls */
        .map-cell.wall-north:not(.wall-south):not(.wall-east):not(.wall-west)::before {
            content: "▲";
            position: absolute;
            top: 2px;
            color: #ff4444;
            font-size: 10px;
            opacity: 0.8;
        }

        .map-cell.wall-south:not(.wall-north):not(.wall-east):not(.wall-west)::before {
            content: "▼";
            position: absolute;
            bottom: 2px;
            color: #ff4444;
            font-size: 10px;
            opacity: 0.8;
        }

        .map-cell.wall-east:not(.wall-north):not(.wall-south):not(.wall-west)::before {
            content: "▶";
            position: absolute;
            right: 2px;
            color: #ff4444;
            font-size: 10px;
            opacity: 0.8;
        }

        .map-cell.wall-west:not(.wall-north):not(.wall-south):not(.wall-east)::before {
            content: "◀";
            position: absolute;
            left: 2px;
            color: #ff4444;
            font-size: 10px;
            opacity: 0.8;
        }

        /* Completely blocked cell (all 4 walls) */
        .map-cell.wall-north.wall-south.wall-east.wall-west {
            background: #1a1010 !important;
            border: 4px solid #8b0000 !important;
            box-shadow: inset 0 0 12px rgba(139, 0, 0, 0.6);
            cursor: not-allowed;
        }

        .map-cell.wall-north.wall-south.wall-east.wall-west::after {
            content: "⛔";
            color: #cd5c5c;
            font-size: 18px;
            position: absolute;
            text-shadow: 0 0 6px rgba(205, 92, 92, 0.8);
        }

        .map-cell.wall-north.wall-south.wall-east.wall-west:hover {
            border-color: #b22222;
        }

        /* Hover tooltip */
        .map-cell:hover .map-tooltip {
            display: block;
        }

        .map-tooltip {
            display: none;
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: #fff;
            border: 2px solid #000;
            padding: 5px 10px;
            white-space: nowrap;
            z-index: 1000;
            font-size: 10px;
            color: #000;
            margin-bottom: 5px;
            pointer-events: none;
        }

        .map-tooltip::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 5px solid transparent;
            border-top-color: #000;
        }

        /* Item Detail Modal */
        .item-detail-modal .modal-content {
            max-width: 500px;
        }

        .region-indicator {
            text-align: center;
            color: #000;
            font-family: 'Courier New', monospace;
            margin-bottom: 10px;
            padding: 5px;
            border: 2px solid #000;
            background: #fff;
            font-size: 14px;
        }

        .region-indicator.underground {
            color: #000;
            border-color: #000;
            background: #fff;
        }

        .item-detail-header {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
            border-bottom: 2px solid #000;
            padding-bottom: 15px;
        }

        .item-detail-icon {
            font-size: 48px;
        }

        .item-detail-title {
            flex: 1;
        }

        .item-detail-name {
            color: #000;
            font-size: 24px;
            margin-bottom: 5px;
        }

        .item-detail-type {
            color: #000;
            font-size: 14px;
        }

        .item-detail-stats {
            background: #fff;
            border: 2px solid #000;
            padding: 15px;
            margin: 15px 0;
            border-radius: 0;
        }

        .item-stat-row {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid #000;
        }

        .item-stat-row:last-child {
            border-bottom: none;
        }

        .item-stat-label {
            color: #000;
        }

        .item-stat-value {
            color: #000;
            font-weight: bold;
        }

        .item-description {
            color: #000;
            line-height: 1.6;
            margin: 15px 0;
        }

        .item-actions {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .item-action-btn {
            flex: 1;
            background: #fff;
            border: 2px solid #000;
            color: #000;
            padding: 10px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            font-weight: bold;
            transition: none;
        }

        .item-action-btn:hover {
            background: #000;
            color: #fff;
        }

        .item-action-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        /* Item Image Section */
        .item-image-section {
            background: #fff;
            border: 2px solid #000;
            border-radius: 0;
            padding: 15px;
            margin: 15px 0;
        }

        .item-image-container {
            background: #fff;
            border: 2px solid #000;
            border-radius: 0;
            padding: 10px;
            min-height: 200px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .item-generated-image {
            max-width: 100%;
            max-height: 300px;
            object-fit: contain;
            border: 2px solid #000;
            animation: fadeIn 0.5s ease-in;
            cursor: pointer;
        }

        /* Image Gallery */
        .image-gallery {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid var(--border-wood);
        }

        .gallery-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .gallery-title {
            color: var(--primary-gold);
            font-size: 12px;
            font-weight: bold;
        }

        .gallery-count {
            color: var(--text-dark);
            font-size: 11px;
        }

        .gallery-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            margin-bottom: 10px;
        }

        .gallery-thumbnail {
            position: relative;
            aspect-ratio: 1;
            border: 2px solid var(--border-wood);
            border-radius: 3px;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.2s;
            background: var(--bg-darker-brown);
        }

        .gallery-thumbnail:hover {
            border-color: var(--primary-gold);
            box-shadow: 0 0 10px rgba(201, 148, 26, 0.4);
            transform: scale(1.05);
        }

        .gallery-thumbnail.featured {
            border-color: var(--accent-amber);
            box-shadow: 0 0 15px rgba(212, 168, 42, 0.6);
        }

        .gallery-thumbnail.featured::after {
            content: "⭐";
            position: absolute;
            top: 2px;
            right: 2px;
            font-size: 12px;
            text-shadow: 0 0 5px #000;
        }

        .gallery-thumbnail img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .gallery-pagination {
            display: flex;
            justify-content: center;
            gap: 5px;
            margin-top: 10px;
        }

        .page-btn {
            background: var(--bg-deep-brown);
            border: 1px solid var(--border-wood);
            color: var(--text-light);
            padding: 4px 8px;
            cursor: pointer;
            font-size: 11px;
            border-radius: 3px;
            transition: all 0.2s;
        }

        .page-btn:hover {
            background: var(--border-wood);
            border-color: var(--border-bronze);
        }

        .page-btn.active {
            background: var(--primary-gold);
            color: var(--text-dark);
            border-color: var(--primary-gold);
            font-weight: bold;
        }

        .page-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        /* Custom Prompt Section */
        .custom-prompt-section {
            margin-top: 15px;
            padding: 10px;
            background: rgba(74, 52, 38, 0.2);
            border: 1px solid var(--border-wood);
            border-radius: 3px;
        }

        .custom-prompt-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            margin-bottom: 10px;
            padding: 5px;
            background: rgba(74, 52, 38, 0.3);
            border-radius: 3px;
        }

        .custom-prompt-header:hover {
            background: rgba(74, 52, 38, 0.5);
        }

        .custom-prompt-title {
            color: var(--primary-gold);
            font-size: 12px;
            font-weight: bold;
        }

        .custom-prompt-toggle {
            color: var(--accent-brown);
            font-size: 14px;
        }

        .custom-prompt-content {
            display: none;
        }

        .custom-prompt-content.expanded {
            display: block;
        }

        .custom-prompt-textarea {
            width: 100%;
            min-height: 60px;
            background: var(--bg-darker-brown);
            border: 1px solid var(--border-wood);
            color: var(--text-light);
            font-family: 'Courier New', monospace;
            font-size: 12px;
            padding: 8px;
            border-radius: 3px;
            resize: vertical;
            margin-bottom: 8px;
        }

        .custom-prompt-textarea:focus {
            outline: none;
            border-color: var(--primary-gold);
            box-shadow: 0 0 8px rgba(201, 148, 26, 0.3);
        }

        .custom-prompt-helper {
            color: var(--accent-brown);
            font-size: 10px;
            margin-bottom: 8px;
            font-style: italic;
        }

        .custom-prompt-counter {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-size: 10px;
        }

        .char-count {
            color: var(--accent-brown);
        }

        .char-count.warning {
            color: var(--hp-yellow);
        }

        .char-count.error {
            color: var(--alert-rust);
        }

        .prompt-preview-section {
            background: #000;
            border: 1px solid #0a0;
            border-radius: 3px;
            padding: 8px;
            margin-bottom: 8px;
            max-height: 100px;
            overflow-y: auto;
        }

        .prompt-preview-label {
            color: #0ff;
            font-size: 10px;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .prompt-preview-text {
            font-size: 11px;
            line-height: 1.4;
        }

        .prompt-preview-base {
            color: #0a0;
        }

        .prompt-preview-custom {
            color: #ff0;
            font-weight: bold;
        }

        .prompt-preview-suffix {
            color: #0a0;
        }

        .custom-prompt-buttons {
            display: flex;
            gap: 5px;
        }

        .custom-prompt-btn {
            flex: 1;
            background: #001100;
            border: 1px solid #0a0;
            color: #0f0;
            padding: 6px;
            font-size: 11px;
            cursor: pointer;
            border-radius: 3px;
            transition: all 0.2s;
        }

        .custom-prompt-btn:hover {
            background: #003300;
            border-color: #0ff;
        }

        .custom-prompt-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .validation-message {
            font-size: 10px;
            padding: 5px;
            border-radius: 3px;
            margin-bottom: 8px;
        }

        .validation-warning {
            background: rgba(255, 255, 0, 0.1);
            border: 1px solid #ff0;
            color: #ff0;
        }

        .validation-error {
            background: rgba(255, 0, 0, 0.1);
            border: 1px solid #f00;
            color: #f00;
        }

        .item-image-loading {
            color: #0ff;
            font-size: 14px;
            text-align: center;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .item-image-placeholder {
            text-align: center;
            color: #0a0;
        }

        .item-image-icon {
            font-size: 64px;
            margin-bottom: 10px;
            opacity: 0.5;
        }

        .item-image-text {
            font-size: 12px;
            color: #0a0;
        }

        /* Navigation panel - inside actions-navigation container */
        .navigation-panel {
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        .navigation-wrapper {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        /* Contextual Actions - Left Side */
        .contextual-actions-panel {
            display: flex;
            flex-direction: column;
            justify-content: flex-start;  /* center → flex-start to prevent cutoff */
            align-items: stretch;
            border-right: 3px solid var(--border-wood);
            padding-right: 15px;
            gap: 8px;
            height: 100%;  /* Ensure full height */
        }

        .contextual-actions {
            display: flex;
            flex-direction: column;
            gap: 8px;
            width: 100%;
        }

        .context-button {
            background: linear-gradient(180deg, var(--border-bronze), var(--accent-brown));
            border: 3px solid var(--border-wood);
            border-radius: 6px;
            color: var(--text-light);
            font-size: 11px;  /* 12px → 11px */
            font-weight: bold;
            padding: 12px 14px;  /* 14px 16px → 12px 14px */
            cursor: pointer;
            text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.8);
            box-shadow:
                0 4px 0 var(--bg-darker-brown),
                0 6px 8px rgba(0, 0, 0, 0.5);
            transition: all 0.15s;
            white-space: nowrap;
            text-align: center;
        }

        .context-button:hover {
            background: linear-gradient(180deg, var(--primary-gold), var(--border-bronze));
            border-color: var(--primary-gold);
            transform: translateY(2px);
            box-shadow:
                0 2px 0 var(--bg-darker-brown),
                0 4px 8px rgba(0, 0, 0, 0.6);
        }

        .context-button:active {
            transform: translateY(1px);
        }

        /* Navigation - Right Side */
        .navigation-wrapper {
            display: flex;
            flex-direction: column;
            justify-content: flex-start;  /* center → flex-start */
            align-items: center;
            padding-left: 10px;
            height: 100%;  /* Ensure full height */
        }

        .navigation {
            display: grid;
            grid-template-columns: repeat(3, 85px);  /* 90px → 85px to fit better */
            grid-template-rows: repeat(3, 42px);  /* 45px → 42px to fit all rows */
            gap: 6px;  /* 8px → 6px to save space */
            max-width: 320px;
            justify-content: center;
        }

        .nav-button {
            background: linear-gradient(180deg, var(--panel-parchment), var(--panel-parchment-dark));
            border: 3px solid var(--border-wood);
            border-radius: 6px;
            color: var(--text-dark);
            font-size: 11px;
            font-weight: bold;
            cursor: pointer;
            text-shadow: 1px 1px 0 rgba(255, 255, 255, 0.3);
            box-shadow:
                inset 0 0 0 1px var(--border-bronze),
                2px 2px 4px rgba(0, 0, 0, 0.3);
            transition: all 0.15s;
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            line-height: 1.3;
        }

        .nav-button:hover {
            background: linear-gradient(180deg, var(--accent-amber), var(--border-bronze));
            border-color: var(--primary-gold);
            transform: scale(1.05);
            box-shadow:
                inset 0 0 0 1px var(--primary-gold),
                4px 4px 8px rgba(0, 0, 0, 0.5);
        }

        .nav-button:active {
            transform: scale(0.95);
            box-shadow: inset 2px 2px 4px rgba(0, 0, 0, 0.4);
        }

        .nav-button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            filter: grayscale(1);
        }

        #north { grid-column: 2; grid-row: 1; }
        #west { grid-column: 1; grid-row: 2; }
        #examine { grid-column: 2; grid-row: 2; }
        #east { grid-column: 3; grid-row: 2; }
        #south { grid-column: 2; grid-row: 3; }

        /* Actions & Navigation container - bottom of main area */
        .actions-navigation-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            min-height: 150px;
        }

        .inventory-panel {
            flex: 1;
            min-height: 0;
            display: flex;
            flex-direction: column;
        }

        .inventory-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 5px;
            overflow-y: auto;
            flex: 1;
            min-height: 0;
        }

        .inventory-item {
            background: var(--panel-parchment-dark);
            border: 3px solid var(--border-wood);
            border-radius: 4px;
            padding: var(--space-md);  /* 10px → 12px, use spacing variable */
            margin-bottom: var(--space-sm);  /* Use spacing variable (8px) */
            cursor: pointer;
            box-shadow:
                inset 0 0 0 1px var(--border-bronze),
                2px 2px 4px rgba(0, 0, 0, 0.3);
            transition: all 0.2s;
        }

        .inventory-item:last-child {
            margin-bottom: 0;  /* Remove margin on last item */
        }

        .inventory-item:hover {
            background: var(--accent-amber);
            border-color: var(--primary-gold);
            transform: translateX(4px);
            box-shadow:
                inset 0 0 0 1px var(--primary-gold),
                4px 4px 8px rgba(0, 0, 0, 0.5);
        }

        .inventory-item:hover .item-name,
        .inventory-item:hover .item-desc {
            color: var(--text-dark);
        }

        .item-name {
            color: var(--text-dark);
            font-size: 13px;
            font-weight: bold;
        }

        .item-desc {
            color: var(--accent-brown);
            font-size: 11px;
            font-style: italic;
        }

        /* Action Bar - HIDDEN (redundant with Actions panel) */
        .action-panel {
            display: none;  /* Removed from layout */
        }

        .action-button {
            background: linear-gradient(180deg, var(--border-bronze), var(--accent-brown));
            color: var(--text-light);
            border: 3px solid var(--border-wood);
            border-radius: 6px;
            padding: 12px 20px;
            font-size: 11px;
            font-weight: bold;
            cursor: pointer;
            text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.8);
            box-shadow:
                0 4px 0 var(--bg-darker-brown),
                0 6px 8px rgba(0, 0, 0, 0.5);
            transition: all 0.1s;
        }

        .action-button:hover {
            background: linear-gradient(180deg, var(--primary-gold), var(--border-bronze));
            transform: translateY(2px);
            box-shadow:
                0 2px 0 var(--bg-darker-brown),
                0 4px 6px rgba(0, 0, 0, 0.5);
        }

        .action-button:active {
            transform: translateY(4px);
            box-shadow: 0 0 0 var(--bg-darker-brown);
        }

        .action-button.primary {
            background: linear-gradient(180deg, var(--primary-gold), var(--border-bronze));
        }

        .action-button.primary:hover {
            background: linear-gradient(180deg, var(--accent-amber), var(--primary-gold));
        }

        .action-button.danger {
            background: linear-gradient(180deg, var(--alert-rust), var(--accent-brown));
        }

        .action-button.danger:hover {
            background: linear-gradient(180deg, #ff6b6b, var(--alert-rust));
        }

        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            animation: fadeIn 0.3s;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: #fff;
            border: 3px solid #000;
            border-radius: 0;
            padding: 30px;
            max-width: 90%;
            max-height: 90%;
            overflow-y: auto;
            position: relative;
        }

        .modal-close {
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 28px;
            color: #000;
            cursor: pointer;
            font-weight: bold;
        }

        .modal-close:hover {
            color: #000;
        }

        /* Welcome Screen Modal */
        .welcome-modal .modal-content {
            background: linear-gradient(135deg, #2c3e50, #34495e);
            color: #ecf0f1;
            max-width: 600px;
            text-align: center;
            border: 4px solid #d4af37;
            box-shadow: 0 0 40px rgba(212, 175, 55, 0.5);
        }

        .welcome-title {
            font-size: 2.5em;
            font-weight: bold;
            color: #d4af37;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            margin-bottom: 10px;
            letter-spacing: 2px;
        }

        .welcome-subtitle {
            font-size: 1.2em;
            color: #ecf0f1;
            margin-bottom: 30px;
            font-style: italic;
        }

        .welcome-buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 30px;
        }

        .welcome-btn {
            padding: 15px 30px;
            font-size: 1.3em;
            font-weight: bold;
            background: linear-gradient(135deg, #d4af37, #f39c12);
            color: #000;
            border: 3px solid #000;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .welcome-btn:hover {
            background: linear-gradient(135deg, #f39c12, #d4af37);
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(212, 175, 55, 0.8);
        }

        .welcome-btn.secondary {
            background: linear-gradient(135deg, #7f8c8d, #95a5a6);
            color: #fff;
        }

        .welcome-btn.secondary:hover {
            background: linear-gradient(135deg, #95a5a6, #7f8c8d);
        }

        /* Mobile action buttons */
        .mobile-buttons {
            display: none;
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1500;
            gap: 10px;
            flex-direction: column;
        }

        .mobile-action-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: linear-gradient(to bottom, #0a4000, #052000);
            border: 3px solid #0f0;
            color: #0f0;
            font-size: 24px;
            cursor: pointer;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
            display: none;  /* Hidden by default on desktop */
            align-items: center;
            justify-content: center;
        }

        .mobile-action-btn:active {
            background: #0f0;
            color: #000;
        }

        /* Choice Buttons */
        .choices {
            display: flex;
            flex-direction: column;
            gap: 5px;
            margin-top: 10px;
        }

        .choice-button {
            background: linear-gradient(180deg, var(--panel-parchment-dark), var(--accent-brown));
            border: 3px solid var(--border-wood);
            border-radius: 6px;
            color: var(--text-light);
            padding: 12px;
            text-align: left;
            cursor: pointer;
            text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.8);
            box-shadow:
                inset 0 0 0 1px var(--border-bronze),
                2px 2px 4px rgba(0, 0, 0, 0.3);
            transition: all 0.2s;
            font-size: 13px;
            font-weight: bold;
        }

        .choice-button:hover {
            background: linear-gradient(180deg, var(--accent-amber), var(--border-bronze));
            border-color: var(--primary-gold);
            box-shadow:
                inset 0 0 0 1px var(--primary-gold),
                4px 4px 10px rgba(0, 0, 0, 0.6);
            transform: translateX(8px);
        }

        .choice-button::before {
            content: "▶ ";
            color: var(--primary-gold);
            margin-right: 8px;
        }

        /* Responsive Design */
        @media (max-width: 600px) {
            .game-container {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto auto;
            }

            .header {
                grid-column: 1;
                grid-row: 1;
            }

            .main-area {
                grid-column: 1;
                grid-row: 2;
            }

            .right-sidebar {
                grid-column: 1;
                grid-row: 3;
                max-height: 400px;
            }

            .mobile-buttons {
                display: flex;
            }

            .mobile-action-btn {
                display: flex;  /* Show on mobile */
            }

            .actions-navigation-container {
                grid-template-columns: 1fr;
            }

            .navigation {
                grid-template-columns: repeat(3, 100px);
                grid-template-rows: repeat(3, 60px);
            }

            .tabbed-panel {
                max-height: 200px;
            }

            /* Make center map a bit shorter on mobile */
            .map-panel { grid-template-columns: 1fr; }
            .center-map .map-display { min-height: 180px; }
        }

        @media (max-width: 600px) {
            .game-title {
                font-size: 18px;
            }

            .subtitle {
                font-size: 9px;
            }

            .navigation {
                grid-template-columns: repeat(3, 70px);
                grid-template-rows: repeat(3, 45px);
            }

            .tab-button {
                font-size: 8px;
                padding: 6px 2px;
            }

            .viewport {
                font-size: 13px;
            }
        }

        /* Theme Switcher Dropdown - Pixel Art Style */
        .theme-selector-container {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
            z-index: 100;
        }

        .theme-label {
            color: var(--primary-gold);
            font-size: 11px;
            font-family: 'Press Start 2P', monospace;
            text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.5);
        }

        .theme-dropdown {
            background: linear-gradient(180deg, var(--panel-parchment), var(--panel-parchment-dark));
            border: 3px solid var(--border-wood);
            border-radius: 0;  /* Sharp corners for pixel-art */
            color: var(--text-dark);
            font-family: 'Press Start 2P', monospace;
            font-size: 9px;
            padding: 8px 12px;
            cursor: pointer;
            box-shadow:
                inset 1px 1px 0 var(--border-bronze),
                2px 2px 4px rgba(0, 0, 0, 0.3);
            transition: all 0.2s;
            outline: none;
        }

        .theme-dropdown:hover {
            background: linear-gradient(180deg, var(--primary-gold), var(--accent-amber));
            border-color: var(--border-bronze);
            transform: translateY(-1px);
            box-shadow:
                inset 1px 1px 0 var(--primary-gold),
                3px 3px 6px rgba(0, 0, 0, 0.4);
        }

        .theme-dropdown:focus {
            border-color: var(--border-bronze);
            box-shadow:
                0 0 0 2px var(--primary-gold),
                2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .theme-dropdown option {
            background: var(--panel-parchment);
            color: var(--text-dark);
            font-family: 'Press Start 2P', monospace;
            font-size: 9px;
            padding: 8px;
        }
    </style>
</head>
<body data-theme="blackwhite">
    <div class="game-container">
        <!-- Header -->
        <div class="header panel">
            <div class="game-title">⚔ THE EMBERPEAK EXPEDITION ⚔</div>
            <div class="subtitle">AN AI-POWERED DUNGEON & DRAGONS ADVENTURE</div>
        </div>

        <!-- Main Gameplay Area (70% - Left Side) -->
        <div class="main-area">
            <!-- Adventure Log -->
            <div class="viewport-container panel">
                <div class="panel-title">ADVENTURE LOG</div>
                <div class="current-location-indicator" id="current-location">
                    <span class="location-icon">📍</span>
                    <span class="location-name">Starting Tavern</span>
                </div>
                <div class="viewport" id="viewport">
                    <div class="text-line quest">Welcome, brave adventurer!</div>
                    <div class="text-line quest">Your quest: Rescue miners trapped beneath Emberpeak and seal the shattered rune.</div>
                    <div class="text-line">You find yourself in a dimly lit tavern. The air is thick with pipe smoke and hushed conversations.</div>
                    <div class="text-line">Two seasoned adventurers sit at the bar - a cunning Rogue and a battle-hardened Fighter.</div>
                    <div class="text-line">They turn to greet you as you approach...</div>
                    <div class="text-line cursor"></div>
                </div>
            </div>

            <!-- Map Section (Center) -->
            <div class="center-map panel">
                <div class="panel-title">MAP</div>
                <div class="map-panel">
                    <div class="map-display">
                        <div class="map-grid" id="map"></div>
                    </div>
                    <div class="map-legend">
                        <div class="map-legend-title">MAP LEGEND</div>
                        <div class="map-legend-items">
                            <div class="map-legend-item">
                                <div class="map-legend-symbol legend-unexplored">?</div>
                                <span style="color: var(--text-light);">Unexplored (Can Enter)</span>
                            </div>
                            <div class="map-legend-item">
                                <div class="map-legend-symbol legend-visited">🍺</div>
                                <span style="color: var(--text-light);">Visited</span>
                            </div>
                            <div class="map-legend-item">
                                <div class="map-legend-symbol legend-wall">▲</div>
                                <span style="color: var(--text-light);">Blocked Direction</span>
                            </div>
                            <div class="map-legend-item">
                                <div class="map-legend-symbol legend-blocked">⛔</div>
                                <span style="color: var(--text-light);">Fully Blocked</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Actions & Navigation (Side by Side) -->
            <div class="actions-navigation-container">
                <!-- Actions Panel -->
                <div class="contextual-actions-panel panel">
                    <div class="panel-title">ACTIONS</div>
                    <div class="contextual-actions" id="contextual-actions">
                        <!-- Dynamically populated based on context -->
                    </div>
                </div>

                <!-- Navigation Panel -->
                <div class="navigation-panel panel">
                    <div class="panel-title">NAVIGATION</div>
                    <div class="navigation">
                        <button class="nav-button" id="north">▲<br>NORTH</button>
                        <button class="nav-button" id="west">◄<br>WEST</button>
                        <button class="nav-button" id="examine">👁<br>LOOK</button>
                        <button class="nav-button" id="east">►<br>EAST</button>
                        <button class="nav-button" id="south">▼<br>SOUTH</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Player Status Sidebar (30% - Right Side) -->
        <div class="right-sidebar">
            <!-- Character Panel (Top) -->
            <div class="character-panel panel">
                <div class="panel-title">CHARACTER</div>
                <div class="stats-grid">
                    <div class="stat-label">Name:</div>
                    <div class="stat-value" id="char-name">Hero 1</div>

                    <div class="stat-label">Class:</div>
                    <div class="stat-value" id="char-class">Rogue</div>

                    <div class="stat-label">Level:</div>
                    <div class="stat-value">3</div>

                    <div class="hp-bar-container">
                        <div class="hp-bar" id="hp-bar" style="width: 100%">
                            <span id="hp-text">50 / 50 HP</span>
                        </div>
                    </div>

                    <div class="stat-label">STR:</div>
                    <div class="stat-value">14 (+2)</div>

                    <div class="stat-label">DEX:</div>
                    <div class="stat-value">18 (+4)</div>

                    <div class="stat-label">CON:</div>
                    <div class="stat-value">12 (+1)</div>
                </div>
            </div>

            <!-- Scene Viewer (Middle) -->
            <div class="scene-viewer-panel panel">
                <div class="panel-title">SCENE VIEWER 🍌</div>
                <div class="scene-viewer-content">
                    <img id="scene-image" class="scene-image" alt="Generated scene">
                    <div id="scene-loading" class="scene-loading">
                        Generating scene with Nano Banana
                    </div>
                    <div id="scene-error" class="scene-error"></div>
                    <div id="scene-fallback" class="scene-fallback"></div>
                </div>
            </div>

            <!-- Tabbed Panel (Bottom) - Inventory/Map/Quest Log -->
            <div class="tabbed-panel panel">
                <div class="panel-title">REFERENCE</div>

                <!-- Tab Buttons -->
                <div class="tab-buttons">
                    <button class="tab-button active" data-tab="inventory">
                        INVENTORY
                        <span class="tab-badge" id="inventory-count">4</span>
                        <span class="tab-hint">Press 1</span>
                    </button>
                    <button class="tab-button" data-tab="quest">
                        QUEST LOG
                        <span class="tab-badge" id="quest-count">4</span>
                        <span class="tab-hint">Press 2</span>
                    </button>
                </div>

                <!-- Tab Content: Inventory -->
                <div class="tab-content active" id="tab-inventory">
                    <div class="inventory-panel">
                        <div class="inventory-grid" id="inventory">
                            <div class="inventory-item">
                                <div class="item-name">Dagger</div>
                                <div class="item-desc">1d4 damage</div>
                            </div>
                            <div class="inventory-item">
                                <div class="item-name">Lockpicks</div>
                                <div class="item-desc">+2 lockpick bonus</div>
                            </div>
                            <div class="inventory-item">
                                <div class="item-name">Rope (50ft)</div>
                                <div class="item-desc">Useful tool</div>
                            </div>
                            <div class="inventory-item">
                                <div class="item-name">Torch</div>
                                <div class="item-desc">Light source</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Map tab removed: map is now always visible in main area -->

                <!-- Tab Content: Quest Log -->
                <div class="tab-content" id="tab-quest">
                    <div class="quest-panel">
                        <div class="quest-objectives">
                            <div class="objective" id="obj1">Gather your party</div>
                            <div class="objective" id="obj2">Reach Emberpeak Mines</div>
                            <div class="objective" id="obj3">Rescue the trapped miners</div>
                            <div class="objective" id="obj4">Seal the shattered rune</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- System Console (Hidden by default - can be toggled) -->
        <div class="system-console-container panel" style="display: none;">
            <div class="panel-title">[ SYSTEM CONSOLE ]</div>
            <div class="system-console" id="system-console">
                <div class="system-log info">&gt; System initialized...</div>
                <div class="system-log success">&gt; Backend connection: Ready</div>
                <div class="system-log info">&gt; Awaiting game events...</div>
            </div>
        </div>
    </div>

    <!-- Mobile Action Buttons -->
    <div class="mobile-buttons">
        <button class="mobile-action-btn" id="mobile-map-btn" title="Map">🗺</button>
        <button class="mobile-action-btn" id="mobile-inv-btn" title="Inventory">🎒</button>
        <button class="mobile-action-btn" id="mobile-char-btn" title="Character">👤</button>
    </div>

    <!-- Map Modal -->
    <div class="modal" id="map-modal">
        <div class="modal-content">
            <span class="modal-close" id="close-map">&times;</span>
            <div class="panel-title">MAP</div>
            <div id="region-indicator" class="region-indicator"></div>
            <div class="map-display" style="margin-top: 20px;">
                <div class="map-grid" id="map-modal-grid"></div>
            </div>
        </div>
    </div>

    <!-- Inventory Modal -->
    <div class="modal" id="inv-modal">
        <div class="modal-content">
            <span class="modal-close" id="close-inv">&times;</span>
            <div class="panel-title">INVENTORY</div>
            <div class="inventory-grid" id="inventory-modal" style="margin-top: 20px; max-height: 400px;">
                <!-- Will be populated by JS -->
            </div>
        </div>
    </div>

    <!-- Character Modal -->
    <div class="modal" id="char-modal">
        <div class="modal-content">
            <span class="modal-close" id="close-char">&times;</span>
            <div class="panel-title">CHARACTER</div>
            <div class="stats-grid" style="margin-top: 20px; font-size: 16px;">
                <div class="stat-label">Name:</div>
                <div class="stat-value">Hero 1</div>

                <div class="stat-label">Class:</div>
                <div class="stat-value">Rogue</div>

                <div class="stat-label">Level:</div>
                <div class="stat-value">3</div>

                <div class="hp-bar-container">
                    <div class="hp-bar" style="width: 100%">
                        <span>50 / 50 HP</span>
                    </div>
                </div>

                <div class="stat-label">STR:</div>
                <div class="stat-value">14 (+2)</div>

                <div class="stat-label">DEX:</div>
                <div class="stat-value">18 (+4)</div>

                <div class="stat-label">CON:</div>
                <div class="stat-value">12 (+1)</div>

                <div class="stat-label">INT:</div>
                <div class="stat-value">10 (+0)</div>

                <div class="stat-label">WIS:</div>
                <div class="stat-value">13 (+1)</div>

                <div class="stat-label">CHA:</div>
                <div class="stat-value">16 (+3)</div>
            </div>
            <div style="margin-top: 20px;">
                <div class="panel-title">QUEST LOG</div>
                <div class="quest-objectives">
                    <div class="objective">Gather your party</div>
                    <div class="objective">Reach Emberpeak Mines</div>
                    <div class="objective">Rescue the trapped miners</div>
                    <div class="objective">Seal the shattered rune</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Item Detail Modal -->
    <div class="modal item-detail-modal" id="item-modal">
        <div class="modal-content">
            <span class="modal-close" id="close-item">&times;</span>
            <div id="item-detail-content"></div>
        </div>
    </div>

    <!-- NPC Dialogue Modal -->
    <div class="modal" id="npc-modal">
        <div class="modal-content">
            <span class="modal-close" id="close-npc">&times;</span>
            <div class="panel-title">NPCs</div>
            <div id="npc-modal-body" style="margin-top: 20px; max-height: 400px; overflow: auto;"></div>
        </div>
    </div>

    <!-- Welcome Screen Modal -->
    <div class="modal welcome-modal active" id="welcome-modal">
        <div class="modal-content">
            <div class="welcome-title">⚔️ THE EMBERPEAK EXPEDITION ⚔️</div>
            <div class="welcome-subtitle">An AI-Powered Dungeon & Dragons Adventure</div>
            <div style="margin: 30px 0; padding: 20px; background: rgba(0,0,0,0.3); border-radius: 8px;">
                <p style="font-size: 1.1em; line-height: 1.6;">
                    Brave the dangers of Emberpeak Mine, where miners have been trapped by a shattered magical rune.
                    Rescue the survivors, seal the corruption, and claim your glory!
                </p>
            </div>
            <div class="welcome-buttons">
                <button class="welcome-btn" id="new-game-btn">🎮 NEW ADVENTURE</button>
                <button class="welcome-btn secondary" id="load-game-btn">📂 LOAD GAME</button>
                <button class="welcome-btn secondary" id="continue-game-btn" style="display: none;">▶️ CONTINUE</button>
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // COMPREHENSIVE LOGGING UTILITY
        // ============================================
        const GameLogger = {
            enabled: true,
            logCount: 0,

            log(category, action, details = {}) {
                if (!this.enabled) return;
                this.logCount++;
                const timestamp = new Date().toISOString();
                const logStyle = this.getStyle(category);

                console.groupCollapsed(
                    `%c[${this.logCount}] ${category.toUpperCase()}`,
                    logStyle,
                    `→ ${action}`
                );
                console.log('⏰ Time:', timestamp);
                console.log('📋 Details:', details);
                console.trace('📍 Stack trace');
                console.groupEnd();
            },

            getStyle(category) {
                const styles = {
                    button: 'background: #3498db; color: white; padding: 2px 5px; border-radius: 3px; font-weight: bold;',
                    action: 'background: #2ecc71; color: white; padding: 2px 5px; border-radius: 3px; font-weight: bold;',
                    state: 'background: #e74c3c; color: white; padding: 2px 5px; border-radius: 3px; font-weight: bold;',
                    navigation: 'background: #f39c12; color: white; padding: 2px 5px; border-radius: 3px; font-weight: bold;',
                    quest: 'background: #9b59b6; color: white; padding: 2px 5px; border-radius: 3px; font-weight: bold;',
                    combat: 'background: #e67e22; color: white; padding: 2px 5px; border-radius: 3px; font-weight: bold;',
                    save: 'background: #1abc9c; color: white; padding: 2px 5px; border-radius: 3px; font-weight: bold;',
                    ui: 'background: #34495e; color: white; padding: 2px 5px; border-radius: 3px; font-weight: bold;',
                    system: 'background: #7f8c8d; color: white; padding: 2px 5px; border-radius: 3px; font-weight: bold;'
                };
                return styles[category] || styles.system;
            },

            button(buttonName, details = {}) {
                this.log('button', `Clicked: ${buttonName}`, details);
            },

            action(actionName, details = {}) {
                this.log('action', actionName, details);
            },

            state(stateName, newValue, oldValue = null) {
                this.log('state', `Changed: ${stateName}`, { oldValue, newValue });
            },

            navigation(direction, location) {
                this.log('navigation', `Moving ${direction}`, location);
            },

            quest(questEvent, details = {}) {
                this.log('quest', questEvent, details);
            },

            combat(event, details = {}) {
                this.log('combat', event, details);
            },

            save(operation, details = {}) {
                this.log('save', operation, details);
            },

            ui(event, details = {}) {
                this.log('ui', event, details);
            },

            system(event, details = {}) {
                this.log('system', event, details);
            }
        };

        // Log initial page load
        console.log('%c🎮 AI D&D GAME INITIALIZED', 'font-size: 20px; color: #d4af37; font-weight: bold;');
        console.log('%cComprehensive logging enabled. All actions will be tracked.', 'color: #2ecc71; font-weight: bold;');
        GameLogger.system('Page Loaded', { timestamp: new Date().toISOString() });

        // ============================================
        // WELCOME SCREEN HANDLERS
        // ============================================
        window.addEventListener('load', function() {
            GameLogger.ui('Welcome screen displayed');

            const welcomeModal = document.getElementById('welcome-modal');
            const newGameBtn = document.getElementById('new-game-btn');
            const loadGameBtn = document.getElementById('load-game-btn');
            const continueBtn = document.getElementById('continue-game-btn');

            // Check if there's a saved game
            const savedGame = localStorage.getItem('gameState');
            if (savedGame) {
                continueBtn.style.display = 'block';
                GameLogger.save('Saved game detected', { hasData: true });
            }

            // New Game button
            newGameBtn.addEventListener('click', function() {
                GameLogger.button('NEW ADVENTURE', { action: 'Starting new game' });
                welcomeModal.classList.remove('active');
                startNewGame();
            });

            // Load Game button
            loadGameBtn.addEventListener('click', function() {
                GameLogger.button('LOAD GAME', { action: 'Loading saved game' });
                if (savedGame) {
                    welcomeModal.classList.remove('active');
                    setTimeout(() => {
                        const loadBtn = document.getElementById('load-game');
                        if (loadBtn) loadBtn.click();
                    }, 100);
                } else {
                    alert('No saved game found!');
                    GameLogger.save('Load failed', { reason: 'No saved data' });
                }
            });

            // Continue button
            continueBtn.addEventListener('click', function() {
                GameLogger.button('CONTINUE', { action: 'Continuing saved game' });
                welcomeModal.classList.remove('active');
            });
        });

        // ============================================
        // TAB SWITCHING FUNCTIONALITY
        // ============================================
        document.addEventListener('DOMContentLoaded', function() {
            // Tab switching
            const tabButtons = document.querySelectorAll('.tab-button');
            const tabContents = document.querySelectorAll('.tab-content');

            function switchTab(tabName) {
                GameLogger.ui('Tab Switch', { tab: tabName });

                // Remove active class from all buttons and contents
                tabButtons.forEach(btn => btn.classList.remove('active'));
                tabContents.forEach(content => content.classList.remove('active'));

                // Add active class to target tab
                const targetButton = document.querySelector(`[data-tab="${tabName}"]`);
                const targetContent = document.getElementById(`tab-${tabName}`);

                if (targetButton && targetContent) {
                    targetButton.classList.add('active');
                    targetContent.classList.add('active');

                    // Save last active tab to localStorage
                    localStorage.setItem('lastActiveTab', tabName);
                    GameLogger.save('Tab preference saved', { tab: tabName });
                }
            }

            // Click handler
            tabButtons.forEach(button => {
                button.addEventListener('click', function() {
                    const tabName = this.getAttribute('data-tab');
                    GameLogger.button(`Tab Button: ${tabName}`, { method: 'click' });
                    switchTab(tabName);
                });
            });

            // Keyboard shortcuts: 1, 2 for tabs (only when not typing)
            document.addEventListener('keydown', function(e) {
                // Don't trigger if user is typing in an input/textarea
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                    return;
                }

                // Tab shortcuts
                const keyMap = {
                    '1': 'inventory',
                    '2': 'quest'
                };

                if (keyMap[e.key]) {
                    e.preventDefault();
                    GameLogger.button(`Keyboard Shortcut: ${e.key}`, { tab: keyMap[e.key], method: 'keyboard' });
                    switchTab(keyMap[e.key]);
                return;
                }

            // Arrow key movement shortcuts (when not in combat)
            const arrowToDir = {
                'ArrowUp': 'north',
                'ArrowDown': 'south',
                'ArrowLeft': 'west',
                'ArrowRight': 'east'
            };
            if (arrowToDir[e.key]) {
                e.preventDefault();
                move(arrowToDir[e.key]);
            }
            });

            // Restore last active tab on load
            const lastTab = localStorage.getItem('lastActiveTab');
            const validTabs = new Set(['inventory', 'quest']);
            if (lastTab && validTabs.has(lastTab)) {
                switchTab(lastTab);
                GameLogger.save('Restored last tab', { tab: lastTab });
            } else {
                switchTab('inventory');
                GameLogger.save('Restored default tab', { tab: 'inventory' });
            }

            GameLogger.ui('Tab switching initialized', { keyboardShortcuts: '1, 2' });
        });

        // ============================================
        // ITEM DATABASE
        // ============================================
        const itemDatabase = {
            'Dagger': {
                name: 'Dagger',
                type: 'Weapon (Simple, Finesse)',
                icon: '🗡️',
                damage: '1d4',
                damageType: 'Piercing',
                properties: ['Finesse', 'Light', 'Thrown (20/60)'],
                weight: '1 lb',
                value: '2 gp',
                description: 'A small, easily concealed blade. Perfect for sneaking and quick strikes. Can be thrown at range.',
                special: 'Uses DEX modifier for attack and damage rolls.'
            },
            'Lockpicks': {
                name: 'Lockpicks',
                type: 'Tool (Thieves\' Tools)',
                icon: '🔓',
                bonus: '+2',
                skill: 'Sleight of Hand',
                weight: '1 lb',
                value: '25 gp',
                description: 'A set of specialized picks, files, and tension wrenches for opening locks.',
                special: 'Grants advantage on lockpicking checks when used with proficiency.'
            },
            'Rope (50ft)': {
                name: 'Rope (50ft)',
                type: 'Adventuring Gear',
                icon: '🪢',
                durability: '2 hit points',
                capacity: 'Can hold up to 3,000 lbs',
                weight: '10 lbs',
                value: '1 gp',
                description: 'Hempen rope, sturdy and reliable. Essential for climbing, binding, and creative problem-solving.',
                special: 'Can be used to climb, tie up enemies, create trip wires, or form makeshift bridges.'
            },
            'Torch': {
                name: 'Torch',
                type: 'Light Source',
                icon: '🔦',
                lightRadius: '20 ft bright light, 20 ft dim',
                duration: '1 hour',
                weight: '1 lb',
                value: '1 cp',
                description: 'A wooden stick wrapped in oil-soaked rags. Burns brightly for an hour.',
                special: 'Can be used as an improvised weapon (1 fire damage) or to ignite flammable objects.'
            },
            'Miner\'s Note': {
                name: 'Miner\'s Note',
                type: 'Quest Item',
                icon: '📜',
                weight: '0 lb',
                value: 'Priceless',
                description: 'A bloodstained note from the mining camp. It reads: "Tunnel collapsed at west shaft. Seven of us trapped. Running out of air. If anyone finds this... please help. -Foreman Garrett"',
                special: 'This note reveals the location of the trapped miners. They need rescue urgently!'
            },
            'Sealing Stone': {
                name: 'Sealing Stone',
                type: 'Quest Item (Magical)',
                icon: '💠',
                weight: '2 lbs',
                value: 'Ancient Artifact',
                description: 'A perfectly smooth stone that pulses with containment magic. Ancient runes are carved into its surface, glowing with soft blue light.',
                special: 'Can be used to seal corrupted magical artifacts. The miners say it was found in the deepest chamber, placed there by ancient dwarven mages.'
            },
            'Healing Potion': {
                name: 'Healing Potion',
                type: 'Consumable (Potion)',
                icon: '🧪',
                healing: '2d4+2',
                weight: '0.5 lb',
                value: '50 gp',
                description: 'A small vial filled with red liquid that shimmers with restorative magic. Tastes like cherries and hope.',
                special: 'Restores 2d4+2 hit points when consumed as an action. Can be the difference between life and death.'
            }
        };

        // ============================================================
        // CUSTOM PROMPT MANAGEMENT
        // ============================================================

        // Store custom prompts per item (in memory, per session)
        const customPrompts = {};

        /**
         * Toggle custom prompt section expand/collapse
         */
        function toggleCustomPromptSection(itemName) {
            const safeItemName = itemName.replace(/\s+/g, '-');
            const contentEl = document.getElementById(`custom-prompt-content-${safeItemName}`);
            const toggleEl = document.getElementById(`custom-prompt-toggle-${safeItemName}`);

            if (contentEl && toggleEl) {
                contentEl.classList.toggle('expanded');
                toggleEl.textContent = contentEl.classList.contains('expanded') ? '▲' : '▼';
            }
        }

        /**
         * Update custom prompt preview and character count
         */
        function updateCustomPromptPreview(itemName) {
            const safeItemName = itemName.replace(/\s+/g, '-');
            const inputEl = document.getElementById(`custom-prompt-input-${safeItemName}`);
            const countEl = document.getElementById(`char-count-${safeItemName}`);
            const previewEl = document.getElementById(`prompt-preview-${safeItemName}`);
            const validationEl = document.getElementById(`validation-message-${safeItemName}`);

            if (!inputEl) return;

            const customText = inputEl.value;
            const charCount = customText.length;

            // Update character count with color coding
            if (countEl) {
                countEl.textContent = `${charCount}/200`;
                countEl.className = 'char-count';
                if (charCount > 180) {
                    countEl.classList.add('warning');
                }
                if (charCount === 200) {
                    countEl.classList.add('error');
                }
            }

            // Build and show preview
            const item = itemDatabase[itemName];
            if (item && previewEl) {
                const basePrompt = buildBasePrompt(item);
                const suffix = 'Fantasy RPG item, detailed illustration on neutral background, studio lighting, high quality.';

                let previewHTML = `<span class="prompt-preview-base">${basePrompt}</span>`;

                if (customText.trim()) {
                    previewHTML += `<span class="prompt-preview-custom">${customText}</span><span class="prompt-preview-base">. </span>`;
                }

                previewHTML += `<span class="prompt-preview-suffix">${suffix}</span>`;

                previewEl.innerHTML = previewHTML;
            }

            // Validate and show warnings/errors
            if (validationEl) {
                const validation = validateCustomPrompt(customText, itemName);
                if (validation.errors.length > 0) {
                    validationEl.innerHTML = validation.errors.map(err =>
                        `<div class="validation-message validation-error">❌ ${err}</div>`
                    ).join('');
                } else if (validation.warnings.length > 0) {
                    validationEl.innerHTML = validation.warnings.map(warn =>
                        `<div class="validation-message validation-warning">⚠️ ${warn}</div>`
                    ).join('');
                } else {
                    validationEl.innerHTML = '';
                }
            }
        }

        /**
         * Build base prompt for an item
         */
        function buildBasePrompt(item) {
            let prompt = `${item.name}, ${item.description}. `;

            // Add type-specific details
            if (item.damage) {
                prompt += `Weapon that deals ${item.damage} ${item.damageType || ''} damage. `;
            }
            if (item.type.includes('Tool')) {
                prompt += `Detailed crafting tool. `;
            }
            if (item.type.includes('Light')) {
                prompt += `Glowing light source. `;
            }
            if (item.type.includes('Quest')) {
                prompt += `Magical artifact with mystical properties. `;
            }
            if (item.special) {
                prompt += `Special property: ${item.special}. `;
            }

            return prompt;
        }

        /**
         * Validate custom prompt
         * Returns {errors: [], warnings: []}
         */
        function validateCustomPrompt(customPrompt, itemName) {
            const errors = [];
            const warnings = [];

            // Length validation (hard error)
            if (customPrompt.length > 200) {
                errors.push("Custom prompt exceeds 200 character limit");
            }

            // Check for dangerous content (hard error)
            const dangerous = ['<script', 'javascript:', 'onerror', 'eval(', '<?php', '<iframe'];
            for (const pattern of dangerous) {
                if (customPrompt.toLowerCase().includes(pattern)) {
                    errors.push("Invalid content detected in prompt");
                    break;
                }
            }

            // Check for contradictory item mentions (soft warning)
            const otherItems = ['sword', 'bow', 'axe', 'staff', 'shield', 'armor', 'helmet'];
            for (const otherItem of otherItems) {
                if (customPrompt.toLowerCase().includes(otherItem) &&
                    !itemName.toLowerCase().includes(otherItem)) {
                    warnings.push(`Your prompt mentions "${otherItem}" but item is "${itemName}". Image may be confusing.`);
                }
            }

            // Check for obvious contradictions (soft warning)
            const contradictions = ['ignore', 'instead of', 'not a', 'actually a', 'really a'];
            for (const phrase of contradictions) {
                if (customPrompt.toLowerCase().includes(phrase)) {
                    warnings.push(`Phrase "${phrase}" might cause unexpected results`);
                }
            }

            return { errors, warnings };
        }

        /**
         * Clear custom prompt
         */
        function clearCustomPrompt(itemName) {
            const safeItemName = itemName.replace(/\s+/g, '-');
            const inputEl = document.getElementById(`custom-prompt-input-${safeItemName}`);

            if (inputEl) {
                inputEl.value = '';
                updateCustomPromptPreview(itemName);
                delete customPrompts[itemName];
                addText(`🗑️ Cleared custom prompt for ${itemName}`, 'info');
            }
        }

        /**
         * Apply custom prompt for next generation
         */
        function applyCustomPrompt(itemName) {
            const safeItemName = itemName.replace(/\s+/g, '-');
            const inputEl = document.getElementById(`custom-prompt-input-${safeItemName}`);

            if (inputEl) {
                const customText = inputEl.value.trim();
                const validation = validateCustomPrompt(customText, itemName);

                // Block if there are errors
                if (validation.errors.length > 0) {
                    addText(`❌ Cannot apply: ${validation.errors[0]}`, 'damage');
                    return;
                }

                // Save custom prompt
                customPrompts[itemName] = customText;

                if (customText) {
                    addText(`✅ Custom style applied to ${itemName}. Click "Generate New Image" to create!`, 'success');
                } else {
                    addText(`ℹ️ Using default style for ${itemName}`, 'info');
                }
            }
        }

        // ============================================================
        // SCENE CACHE - Prevent Unnecessary Regeneration
        // ============================================================

        class SceneCache {
            constructor() {
                this.storageKey = 'nanoBananaSceneCache';
                this.loadCache();
            }

            loadCache() {
                const stored = localStorage.getItem(this.storageKey);
                this.cache = stored ? JSON.parse(stored) : {};
            }

            saveCache() {
                localStorage.setItem(this.storageKey, JSON.stringify(this.cache));
            }

            /**
             * Generate scene key from location and context
             */
            getSceneKey(location, timeOfDay = 'day', weather = 'clear') {
                return `scene_${location}_${timeOfDay}_${weather}`.toLowerCase().replace(/\s+/g, '-');
            }

            /**
             * Check if scene exists in cache
             */
            has(location, timeOfDay, weather) {
                const key = this.getSceneKey(location, timeOfDay, weather);
                return !!this.cache[key];
            }

            /**
             * Get cached scene
             */
            get(location, timeOfDay, weather) {
                const key = this.getSceneKey(location, timeOfDay, weather);
                const cached = this.cache[key];

                if (cached) {
                    cached.lastUsed = new Date().toISOString();
                    cached.useCount = (cached.useCount || 0) + 1;
                    this.saveCache();
                    console.log(`📦 Using cached scene: ${key} (used ${cached.useCount} times)`);
                    addSystemLog(`📦 Using cached scene: ${key} (used ${cached.useCount} times)`, 'cache');
                }

                return cached;
            }

            /**
             * Store scene in cache
             */
            set(location, imageData, timeOfDay = 'day', weather = 'clear', prompt = '') {
                const key = this.getSceneKey(location, timeOfDay, weather);

                this.cache[key] = {
                    location,
                    imageData,
                    timeOfDay,
                    weather,
                    prompt,
                    timestamp: new Date().toISOString(),
                    lastUsed: new Date().toISOString(),
                    useCount: 1
                };

                this.saveCache();
                console.log(`💾 Cached scene: ${key}`);
                addSystemLog(`💾 Cached scene: ${key}`, 'cache');
            }

            /**
             * Clear old scenes (unused for 7+ days)
             */
            cleanup() {
                const sevenDaysAgo = Date.now() - (7 * 24 * 60 * 60 * 1000);
                let removed = 0;

                for (const [key, scene] of Object.entries(this.cache)) {
                    const lastUsed = new Date(scene.lastUsed).getTime();
                    if (lastUsed < sevenDaysAgo) {
                        delete this.cache[key];
                        removed++;
                    }
                }

                if (removed > 0) {
                    this.saveCache();
                    console.log(`🗑️ Cleaned up ${removed} old scenes`);
                    addSystemLog(`🗑️ Cleaned up ${removed} old scenes from cache`, 'cache');
                }
            }

            /**
             * Get cache statistics
             */
            getStats() {
                const scenes = Object.values(this.cache);
                return {
                    total: scenes.length,
                    totalUses: scenes.reduce((sum, s) => sum + (s.useCount || 1), 0),
                    locations: [...new Set(scenes.map(s => s.location))]
                };
            }

            /**
             * Clear all cached scenes
             */
            clear() {
                this.cache = {};
                this.saveCache();
                console.log('🗑️ Cleared all cached scenes');
                addSystemLog('🗑️ Cleared all cached scenes', 'cache');
            }
        }

        // ============================================================
        // IMAGE LIBRARY - LocalStorage Management
        // ============================================================

        class ImageLibrary {
            constructor() {
                this.storageKey = 'nanoBananaImageLibrary';
                this.loadLibrary();
            }

            loadLibrary() {
                const stored = localStorage.getItem(this.storageKey);
                this.library = stored ? JSON.parse(stored) : {};
            }

            saveLibrary() {
                localStorage.setItem(this.storageKey, JSON.stringify(this.library));
            }

            /**
             * Save an image to the library
             * @param {string} itemName - Name of the item
             * @param {string} imageData - Base64 image data
             * @param {string} customPrompt - Optional custom prompt used
             * @returns {string} Image ID
             */
            saveImage(itemName, imageData, customPrompt = '') {
                if (!this.library[itemName]) {
                    this.library[itemName] = {
                        featured: null,
                        images: []
                    };
                }

                const imageId = `img_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                const imageEntry = {
                    id: imageId,
                    data: imageData,
                    timestamp: new Date().toISOString(),
                    customPrompt: customPrompt || ''
                };

                this.library[itemName].images.push(imageEntry);

                // Set as featured if it's the first image
                if (!this.library[itemName].featured) {
                    this.library[itemName].featured = imageId;
                }

                this.saveLibrary();
                const promptInfo = customPrompt ? ` with custom prompt: "${customPrompt}"` : '';
                console.log(`💾 Saved image ${imageId} for ${itemName}${promptInfo}`);
                addSystemLog(`💾 Saved image ${imageId} for ${itemName}${promptInfo}`, 'success');
                return imageId;
            }

            /**
             * Get all images for an item
             * @param {string} itemName - Name of the item
             * @returns {Array} Array of image objects
             */
            getImages(itemName) {
                return this.library[itemName]?.images || [];
            }

            /**
             * Get featured image for an item
             * @param {string} itemName - Name of the item
             * @returns {Object|null} Featured image object
             */
            getFeaturedImage(itemName) {
                const itemData = this.library[itemName];
                if (!itemData) return null;

                return itemData.images.find(img => img.id === itemData.featured) || null;
            }

            /**
             * Set featured image for an item
             * @param {string} itemName - Name of the item
             * @param {string} imageId - Image ID to set as featured
             */
            setFeaturedImage(itemName, imageId) {
                if (this.library[itemName]) {
                    this.library[itemName].featured = imageId;
                    this.saveLibrary();
                    console.log(`⭐ Set ${imageId} as featured for ${itemName}`);
                    addSystemLog(`⭐ Set ${imageId} as featured for ${itemName}`, 'success');
                }
            }

            /**
             * Delete an image
             * @param {string} itemName - Name of the item
             * @param {string} imageId - Image ID to delete
             */
            deleteImage(itemName, imageId) {
                if (!this.library[itemName]) return;

                this.library[itemName].images = this.library[itemName].images.filter(
                    img => img.id !== imageId
                );

                // If deleted image was featured, set new featured
                if (this.library[itemName].featured === imageId) {
                    const remaining = this.library[itemName].images;
                    this.library[itemName].featured = remaining.length > 0 ? remaining[0].id : null;
                }

                this.saveLibrary();
            }

            /**
             * Get image count for an item
             * @param {string} itemName - Name of the item
             * @returns {number} Number of images
             */
            getImageCount(itemName) {
                return this.library[itemName]?.images.length || 0;
            }
        }

        // ============================================================
        // NANO BANANA IMAGE GENERATOR
        // ============================================================

        class NanoBananaGenerator {
            constructor(apiUrl = 'http://localhost:8000/api/v1') {
                this.apiUrl = apiUrl;
                this.useBackend = true; // Toggle for testing - set to false for placeholder mode
                this.backendAvailable = false;
                this.imageCache = new Map();
                this.isGenerating = false;
                this.quotaExhausted = false;
                this.disabled = false;
                this.imageLibrary = new ImageLibrary();
                this.sceneCache = new SceneCache();

                // Track current scene to avoid regeneration
                this.currentScene = {
                    location: 'emberpeak_entrance',
                    timeOfDay: 'dawn',
                    weather: 'clear'
                };
            }

            /**
             * Initialize the generator and check backend connection
             */
            async initialize() {
                console.log('🍌 Initializing Nano Banana Generator...');
                addSystemLog('🍌 Initializing Nano Banana Generator...', 'info');

                if (!this.useBackend) {
                    console.warn('⚠️ Backend disabled by configuration');
                    this.disabled = true;
                    addText('⚠️ Image generation disabled (placeholder mode)', 'system');
                    return false;
                }

                this.backendAvailable = await this.checkHealth();

                if (!this.backendAvailable) {
                    console.warn('⚠️ Backend offline, using placeholder mode');
                    this.disabled = true;
                    addText('⚠️ Image generation unavailable (backend offline)', 'system');
                    return false;
                }

                console.log('✅ Backend connected and ready');
                addSystemLog('✅ Backend connected and ready', 'success');
                addText('✅ Image generation ready', 'system');
                return true;
            }

            /**
             * Check if the backend server is healthy
             */
            async checkHealth() {
                try {
                    // FastAPI health is at root /health, not /api/v1/health
                    const healthUrl = 'http://localhost:8000/health';
                    const response = await fetch(healthUrl, {
                        method: 'GET',
                        signal: AbortSignal.timeout(5000) // 5 second timeout
                    });
                    if (response.ok) {
                        return true;
                    }
                    this.disabled = true;
                    return false;
                } catch (error) {
                    console.warn('Backend server not available:', error.message);
                    this.disabled = true;
                    return false;
                }
            }

            /**
             * Generate a scene image from a descriptive prompt
             * @param {string} prompt - Description of the scene to generate
             * @param {Object} options - Optional configuration
             * @returns {Promise<string>} Base64 encoded image data
             */
            async generateSceneImage(prompt, options = {}) {
                const aspectRatio = options.aspectRatio || '16:9';
                const subjectName = options.subjectName || prompt.substring(0, 50);
                const cacheKey = `scene_${subjectName}_${aspectRatio}`;

                // Skip if disabled or quota exhausted
                if (this.disabled) {
                    console.warn('🍌 Generation disabled (server offline)');
                    this.showFallbackArt(prompt);
                    return null;
                }

                if (this.quotaExhausted) {
                    console.warn('🍌 Quota exhausted, using fallback art');
                    this.showFallbackArt(prompt);
                    return null;
                }

                // Check memory cache first
                if (this.imageCache.has(cacheKey)) {
                    console.log('📦 Using memory cached image for:', subjectName);
                    return this.imageCache.get(cacheKey);
                }

                try {
                    this.setLoadingState(true);

                    // Step 1: Search database for existing image
                    console.log('🔍 Searching database for:', subjectName);
                    addSystemLog(`🔍 Searching database for: ${subjectName}`, 'api');
                    const searchUrl = `${this.apiUrl}/images/search?subject_name=${encodeURIComponent(subjectName)}&subject_type=scene`;
                    const searchResponse = await fetch(searchUrl);

                    if (searchResponse.ok) {
                        const searchData = await searchResponse.json();
                        if (searchData.total > 0) {
                            console.log('📦 Found in database! Loading from backend...');
                            addSystemLog(`📦 Found in database! Loading image ${searchData.items[0].id}`, 'cache');
                            const image = searchData.items[0];

                            // Get the actual image data
                            const imageResponse = await fetch(`${this.apiUrl}/images/${image.id}`);
                            if (imageResponse.ok) {
                                const imageData = await imageResponse.json();
                                // Backend returns base64 in the response
                                const base64Image = `data:image/webp;base64,${imageData.base64_data || ''}`;
                                this.imageCache.set(cacheKey, base64Image);
                                this.displayImage(base64Image);
                                return base64Image;
                            }
                        }
                    }

                    // Step 2: Generate new image if not found
                    console.log('🍌 Generating new scene:', subjectName);

                    const requestBody = {
                        subject_type: 'scene',
                        subject_name: subjectName,
                        prompt: prompt,
                        aspect_ratio: aspectRatio,
                        component: 'scene-viewer'
                    };

                    // Add custom prompt if provided
                    if (options.customPrompt) {
                        requestBody.custom_prompt = options.customPrompt;
                    }

                    const response = await fetch(`${this.apiUrl}/images/generate`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(requestBody)
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        const errorMsg = errorData.detail?.message || `HTTP ${response.status}`;

                        // Check for quota exhaustion
                        if (response.status === 429) {
                            console.warn('🍌 API quota exhausted');
                            this.quotaExhausted = true;
                            this.showError('API quota exceeded. Using fallback art.');
                            this.showFallbackArt(prompt);
                            return null;
                        }

                        // Other errors
                        console.error('❌ Server error:', errorMsg);
                        this.showError(errorMsg);
                        this.showFallbackArt(prompt);
                        return null;
                    }

                    const data = await response.json();

                    // FastAPI backend returns image data directly
                    if (data.id && data.storage_path_full) {
                        console.log(`✅ Image generated in ${data.generation_time_ms}ms`);
                        addSystemLog(`✅ Image generated in ${data.generation_time_ms}ms (ID: ${data.id})`, 'success');

                        // Get the image data
                        const imageResponse = await fetch(`${this.apiUrl}/images/${data.id}`);
                        if (imageResponse.ok) {
                            const imageData = await imageResponse.json();
                            const base64Image = `data:image/webp;base64,${imageData.base64_data || ''}`;
                            this.imageCache.set(cacheKey, base64Image);
                            this.displayImage(base64Image);
                            return base64Image;
                        }
                    } else {
                        console.warn('⚠️ No image data in response');
                        this.showFallbackArt(prompt);
                        return null;
                    }
                } catch (error) {
                    console.error('❌ Image generation failed:', error);
                    this.showError(error.message);
                    this.showFallbackArt(prompt);
                    return null;
                } finally {
                    this.setLoadingState(false);
                }
            }

            /**
             * Generate a character portrait
             * @param {Object} characterData - Character information
             * @returns {Promise<string>} Base64 encoded image data
             */
            async generateCharacterPortrait(characterData) {
                const prompt = `${characterData.name}, a ${characterData.class}. ${characterData.description || 'Fantasy RPG character portrait'}`;
                return this.generateSceneImage(prompt, { aspectRatio: '1:1', style: 'fantasy_art' });
            }

            /**
             * Generate item artwork
             * @param {string} itemName - Name/description of the item
             * @returns {Promise<string>} Base64 encoded image data
             */
            async generateItemImage(itemName) {
                const prompt = `${itemName}, detailed item illustration on white background`;
                return this.generateSceneImage(prompt, { aspectRatio: '1:1', style: 'fantasy_art' });
            }

            /**
             * Display generated image in the scene viewer
             */
            displayImage(base64Data) {
                const img = document.getElementById('scene-image');
                const fallback = document.getElementById('scene-fallback');
                const error = document.getElementById('scene-error');

                if (img) {
                    // base64Data is already a complete data URI (data:image/webp;base64,...)
                    img.src = base64Data;
                    img.classList.add('loaded');
                    fallback.classList.remove('active');
                    error.classList.remove('active');
                }
            }

            /**
             * Set loading state UI
             */
            setLoadingState(isLoading) {
                this.isGenerating = isLoading;
                const loading = document.getElementById('scene-loading');
                const img = document.getElementById('scene-image');

                if (loading) {
                    if (isLoading) {
                        loading.classList.add('active');
                        img.classList.remove('loaded');
                    } else {
                        loading.classList.remove('active');
                    }
                }
            }

            /**
             * Show error message
             */
            showError(message) {
                const errorEl = document.getElementById('scene-error');
                if (errorEl) {
                    errorEl.textContent = `(Image generation unavailable - using fallback art)`;
                    errorEl.classList.add('active');
                }
            }

            /**
             * Show ASCII fallback art when generation fails
             */
            showFallbackArt(prompt) {
                const fallbackEl = document.getElementById('scene-fallback');
                if (fallbackEl) {
                    const art = this.getAsciiArt(prompt);
                    fallbackEl.textContent = art;
                    fallbackEl.classList.add('active');
                }
            }

            /**
             * Get ASCII art fallback based on prompt keywords
             */
            getAsciiArt(prompt) {
                const lowerPrompt = prompt.toLowerCase();

                if (lowerPrompt.includes('emberpeak') || lowerPrompt.includes('village') || lowerPrompt.includes('entrance')) {
                    return `
    🏔️  EMBERPEAK VILLAGE  🏔️
    ═══════════════════════════
         /\\        /\\
        /  \\      /  \\
       /    \\    /    \\
      /      \\  /      \\
     /________\\/________\\
     |  🚪  ||  🏠  |
     |      ||      |
    ═════════════════════
         WELCOME
                    `;
                } else if (lowerPrompt.includes('mine') || lowerPrompt.includes('cave')) {
                    return `
    ⛏️   EMBERPEAK MINES   ⛏️
    ═══════════════════════════
         ___________
        /           \\
       /   DANGER    \\
      |   🔥  🔥  🔥 |
      |              |
      |_____________/
         |       |
         |  ⚠️   |
    ═══════════════════════
                    `;
                } else {
                    return `
    ⚔️   D&D ADVENTURE   ⚔️
    ═══════════════════════════
         /\\    🏔️    /\\
        /  \\  /  \\  /  \\
       /____\\/____\\/____\\
       |  🗡️  |  🛡️ |
       |______|______|
    ═══════════════════════
      IMAGE UNAVAILABLE
                    `;
                }
            }

            /**
             * Clear the image cache
             */
            clearCache() {
                this.imageCache.clear();
                console.log('🗑️ Image cache cleared');
                addSystemLog('🗑️ Image cache cleared', 'cache');
            }

            /**
             * Check if server is available
             */
            async checkHealth() {
                try {
                    // FastAPI health is at root /health
                    const healthUrl = 'http://localhost:8000/health';
                    const response = await fetch(healthUrl);
                    const data = await response.json();
                    return data.status === 'ok';
                } catch (error) {
                    return false;
                }
            }
        }

        // Initialize Nano Banana Generator
        const nanoBanana = new NanoBananaGenerator();

        // ============================================================
        // END NANO BANANA IMAGE GENERATOR
        // ============================================================

        // Game State
        const gameState = {
            character: {
                name: 'Hero',
                class: 'Rogue',
                level: 3,
                xp: 750,
                stats: {
                    str: 14,
                    dex: 18,
                    con: 12,
                    int: 10,
                    wis: 13,
                    cha: 16
                }
            },
            currentLocation: { x: 3, y: 2 },
            playerHP: 50,
            maxHP: 50,
            turn: 0,
            inCombat: false,
            lastEncounterLocation: null,
            encounterCooldown: 0,
            locations: {
                '3,2': { name: 'Starting Tavern', visited: true, scouted: false, description: 'A warm tavern filled with adventurers.', icon: '🍺', walls: [], region: 'surface' },
                '3,1': { name: 'Town Square', visited: false, scouted: false, description: 'The bustling heart of the village.', icon: '🏛️', walls: ['north', 'east', 'west'], region: 'surface' },
                '4,2': { name: 'Market Street', visited: false, scouted: false, description: 'Merchants hawk their wares.', icon: '🛒', walls: ['north', 'east', 'south'], region: 'surface' },
                '2,2': { name: 'Blacksmith', visited: false, scouted: false, description: 'The clang of hammer on anvil rings out.', icon: '⚒️', walls: ['north', 'west', 'south'], region: 'surface' },
                '3,3': { name: 'City Gates', visited: false, scouted: false, description: 'The path leads to adventure beyond.', icon: '🚪', walls: ['east', 'west'], region: 'surface' },
                '3,4': { name: 'Forest Path', visited: false, scouted: false, description: 'Dark woods surround the winding trail.', icon: '🌲', walls: [], region: 'surface' },
                '4,4': { name: 'Hidden Grove', visited: false, scouted: false, description: 'A mystical clearing pulses with energy.', icon: '✨', walls: ['north', 'east', 'south'], region: 'surface' },
                '2,4': { name: 'Bandit Camp', visited: false, scouted: false, description: 'Danger lurks in this makeshift hideout.', icon: '⚔️', walls: ['west', 'south'], region: 'surface' },
                '1,4': { name: 'Dark Cave', visited: false, scouted: false, description: 'A forbidding cave entrance.', icon: '🕳️', walls: ['north', 'west', 'south'], region: 'surface' },
                '4,3': { name: 'Old Bridge', visited: false, scouted: false, description: 'A rickety bridge over a chasm.', icon: '🌉', walls: ['east', 'south'], region: 'surface' },
                '2,3': { name: 'Cemetery', visited: false, scouted: false, description: 'Ancient tombstones loom in the mist.', icon: '⚰️', walls: ['west', 'south'], region: 'surface' },
                // UNDERGROUND - Emberpeak Mines (Y: 5-9)
                '3,5': { name: 'Mine Entrance', visited: false, scouted: false, description: 'Wooden supports frame the descent into darkness. The air grows cold.', icon: '⛏️', walls: ['east', 'west'], region: 'underground' },
                '3,6': { name: 'Shaft Junction', visited: false, scouted: false, description: 'Three tunnels branch off from this central chamber. Pickaxe marks scar the walls.', icon: '🔦', walls: ['north'], region: 'underground' },
                '2,6': { name: 'Crystal Cavern', visited: false, scouted: false, description: 'Glowing crystals illuminate this natural cave. Beautiful but eerie.', icon: '💎', walls: ['north', 'west', 'south'], region: 'underground' },
                '4,6': { name: 'Dark Passage', visited: false, scouted: false, description: 'The tunnel narrows here. Strange scratching sounds echo ahead.', icon: '🌑', walls: ['north', 'east'], region: 'underground' },
                '3,7': { name: 'Mining Camp', visited: false, scouted: false, description: 'Abandoned tools and bedrolls. The miners left in a hurry.', icon: '⚒️', walls: ['east', 'west'], region: 'underground' },
                '2,7': { name: 'Collapsed Tunnel', visited: false, scouted: false, description: 'Rubble blocks further progress. Survivors could be trapped beyond.', icon: '🪨', walls: ['west', 'south'], region: 'underground' },
                '4,7': { name: 'Underground River', visited: false, scouted: false, description: 'Dark water rushes through carved stone. The sound is deafening.', icon: '💧', walls: ['east', 'south'], region: 'underground' },
                '3,8': { name: 'Deep Chamber', visited: false, scouted: false, description: 'The largest cavern yet. Something ancient dwells here.', icon: '🕳️', walls: ['east', 'west'], region: 'underground' },
                '3,9': { name: 'Rune Chamber', visited: false, scouted: false, description: 'The shattered rune pulses with dark energy. This is what drew evil here.', icon: '✨', walls: ['north', 'east', 'west', 'south'], region: 'underground' },
            },
            inventory: [
                { id: 'dagger', name: 'Dagger', type: 'weapon', damage: '1d4', equipped: true },
                { id: 'lockpicks', name: 'Lockpicks', type: 'tool', uses: 5 },
                { id: 'rope', name: 'Rope', type: 'tool', uses: 10 },
                { id: 'torch', name: 'Torch', type: 'light', uses: 8 }
            ],
            objectives: [
                { id: 'obj1', text: 'Gather your party', completed: false },
                { id: 'obj2', text: 'Reach Emberpeak Mines', completed: false },
                { id: 'obj3', text: 'Rescue the trapped miners', completed: false },
                { id: 'obj4', text: 'Seal the shattered rune', completed: false }
            ],
            questFlags: {
                foundMinersNote: false,
                clearedRubble: false,
                rescuedMiners: false,
                foundSealingStone: false,
                sealedRune: false,
                talkedToSurvivor: false
            }
        };

        // ============================================================
        // DATA-DRIVEN RENDER FUNCTIONS
        // ============================================================

        /**
         * Render character stats from gameState
         */
        function renderCharacterStats() {
            const char = gameState.character;

            // Main character panel
            document.getElementById('char-name').textContent = char.name;
            document.getElementById('char-class').textContent = char.class;

            // Stats (main panel - only shows STR, DEX, CON)
            const mainStats = document.querySelectorAll('.stats-grid .stat-value');
            if (mainStats.length >= 5) {
                mainStats[0].textContent = char.name;
                mainStats[1].textContent = char.class;
                mainStats[2].textContent = char.level;

                // Calculate modifiers
                const strMod = Math.floor((char.stats.str - 10) / 2);
                const dexMod = Math.floor((char.stats.dex - 10) / 2);
                const conMod = Math.floor((char.stats.con - 10) / 2);

                // Update stat displays
                const statLabels = document.querySelectorAll('.stats-grid .stat-label');
                statLabels.forEach((label, idx) => {
                    if (label.textContent === 'STR:') {
                        mainStats[idx].textContent = `${char.stats.str} (${strMod >= 0 ? '+' : ''}${strMod})`;
                    } else if (label.textContent === 'DEX:') {
                        mainStats[idx].textContent = `${char.stats.dex} (${dexMod >= 0 ? '+' : ''}${dexMod})`;
                    } else if (label.textContent === 'CON:') {
                        mainStats[idx].textContent = `${char.stats.con} (${conMod >= 0 ? '+' : ''}${conMod})`;
                    }
                });
            }
        }

        /**
         * Render inventory from gameState
         */
        function renderInventory() {
            const inventoryPanel = document.querySelector('.left-sidebar .item-list');
            const inventoryModal = document.getElementById('inventory-modal');

            // Clear existing
            if (inventoryPanel) {
                inventoryPanel.innerHTML = '';

                // Render each item
                gameState.inventory.forEach(item => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'inventory-item';
                    itemDiv.onclick = () => useItem(item.id);
                    itemDiv.innerHTML = `
                        <div class="item-name">${item.name}${item.equipped ? ' ⚔' : ''}</div>
                        <div class="item-desc">${item.damage || item.type}</div>
                    `;
                    inventoryPanel.appendChild(itemDiv);
                });
            }

            // Update modal inventory too (for mobile)
            if (inventoryModal) {
                inventoryModal.innerHTML = gameState.inventory.map(item => `
                    <div class="inventory-item" onclick="useItem('${item.id}')">
                        <div class="item-name">${item.name}${item.equipped ? ' ⚔' : ''}</div>
                        <div class="item-desc">${item.damage || item.type}</div>
                    </div>
                `).join('');
            }
        }

        /**
         * Render quest objectives from gameState
         */
        function renderObjectives() {
            const questPanel = document.querySelector('.quest-objectives');

            if (questPanel) {
                questPanel.innerHTML = '';

                gameState.objectives.forEach(obj => {
                    const objDiv = document.createElement('div');
                    objDiv.className = `objective ${obj.completed ? 'completed' : ''}`;
                    objDiv.id = obj.id;
                    objDiv.innerHTML = `<span class="checkbox">${obj.completed ? '☑' : '☐'}</span> ${obj.text}`;
                    questPanel.appendChild(objDiv);
                });
            }
        }

        /**
         * Add item to inventory
         */
        function addItem(item) {
            gameState.inventory.push(item);
            renderInventory();
            saveGameState();
        }

        /**
         * Remove item from inventory
         */
        function removeItem(itemId) {
            gameState.inventory = gameState.inventory.filter(i => i.id !== itemId);
            renderInventory();
            saveGameState();
        }

        /**
         * Use an item (placeholder for future item actions)
         */
        function useItem(itemId) {
            const item = gameState.inventory.find(i => i.id === itemId);
            if (!item) return;

            addText(`📦 You examine the ${item.name}.`, '');
            // TODO: Add item-specific actions
        }

        /**
         * Check if inventory contains item by name (helper for quest logic)
         */
        function hasItem(itemName) {
            return gameState.inventory.some(i => i.name === itemName);
        }

        /**
         * Add item by name (helper for quest rewards)
         */
        function addItemByName(itemName, type = 'misc') {
            const item = {
                id: itemName.toLowerCase().replace(/[^a-z0-9]/g, ''),
                name: itemName,
                type: type
            };
            addItem(item);
        }

        /**
         * Remove item by name (helper for quest consumption)
         */
        function removeItemByName(itemName) {
            const item = gameState.inventory.find(i => i.name === itemName);
            if (item) {
                removeItem(item.id);
            }
        }

        // ============================================================
        // ACTION DEBOUNCING
        // ============================================================

        let actionCooldown = false;

        /**
         * Debounce action to prevent spam clicking
         */
        function debounceAction(actionFn, cooldownMs = 300) {
            if (actionCooldown) {
                console.log('⏱️ Action on cooldown');
                addSystemLog('⏱️ Action on cooldown', 'warning');
                return;
            }

            actionCooldown = true;
            actionFn();

            setTimeout(() => {
                actionCooldown = false;
            }, cooldownMs);
        }

        // ============================================================
        // SAVE/LOAD SYSTEM
        // ============================================================

        /**
         * Save game state to localStorage
         */
        let __lastSaveTs = 0;
        function saveGameState() {
            const now = Date.now();
            if (now - __lastSaveTs > 1500) {
                GameLogger.save('Saving game', { location: gameState.currentLocation });
                __lastSaveTs = now;
            }
            const saveData = {
                version: '1.0',
                timestamp: Date.now(),
                state: {
                    character: gameState.character,
                    inventory: gameState.inventory,
                    objectives: gameState.objectives,
                    locations: gameState.locations,
                    currentLocation: gameState.currentLocation,
                    questFlags: gameState.questFlags,
                    playerHP: gameState.playerHP,
                    maxHP: gameState.maxHP,
                    turn: gameState.turn
                }
            };
            localStorage.setItem('aidnd_savegame', JSON.stringify(saveData));
            if (Date.now() - __lastSaveTs > 250) {
                GameLogger.save('Game saved successfully', {
                timestamp: new Date(saveData.timestamp).toISOString(),
                turn: saveData.state.turn,
                location: saveData.state.currentLocation
                });
            }
            addSystemLog('💾 Game saved to localStorage', 'success');
        }

        /**
         * Load game state from localStorage
         */
        function loadGameState() {
            GameLogger.save('Loading game from localStorage');
            const saved = localStorage.getItem('aidnd_savegame');
            if (!saved) {
                GameLogger.save('Load failed', { reason: 'No save data found' });
                return false;
            }

            try {
                const saveData = JSON.parse(saved);
                GameLogger.save('Save data parsed', {
                    version: saveData.version,
                    timestamp: new Date(saveData.timestamp).toISOString()
                });

                // Restore state
                gameState.character = saveData.state.character;
                gameState.inventory = saveData.state.inventory;
                gameState.objectives = saveData.state.objectives;
                gameState.locations = saveData.state.locations;
                gameState.currentLocation = saveData.state.currentLocation;
                gameState.questFlags = saveData.state.questFlags;
                gameState.playerHP = saveData.state.playerHP;
                gameState.maxHP = saveData.state.maxHP;
                gameState.turn = saveData.state.turn;

                GameLogger.state('Game state restored', saveData.state.currentLocation);

                // Render everything
                renderCharacterStats();
                renderInventory();
                renderObjectives();
                updateMap();
                updateHP();

                addText('💾 Game loaded successfully!', 'success');
                GameLogger.save('Game loaded successfully', {
                    turn: saveData.state.turn,
                    location: saveData.state.currentLocation,
                    hp: saveData.state.playerHP
                });
                addSystemLog('✅ Game loaded from localStorage', 'success');
                return true;
            } catch (e) {
                GameLogger.save('Load failed', { reason: 'Parse error', error: e.message });
                addText('⚠️ Failed to load save game', 'damage');
                return false;
            }
        }

        /**
         * Reset game state (new game)
         */
        function resetGameState() {
            if (confirm('Start a new game? All progress will be lost.')) {
                startNewGame();
            }
        }

        /**
         * Initialize a completely new game without page reload
         */
        function startNewGame() {
            GameLogger.system('Starting new game', { cleared: 'localStorage and gameState' });

            // Clear saved game
            localStorage.removeItem('aidnd_savegame');
            localStorage.removeItem('gameState');

            // Reset game state to initial values
            gameState.character = {
                name: 'Hero',
                class: 'Rogue',
                level: 3,
                xp: 750,
                stats: { str: 14, dex: 18, con: 12, int: 10, wis: 13, cha: 16 }
            };
            gameState.currentLocation = { x: 3, y: 2 };
            gameState.playerHP = 50;
            gameState.maxHP = 50;
            gameState.turn = 0;
            gameState.inCombat = false;
            gameState.lastEncounterLocation = null;
            gameState.encounterCooldown = 0;

            // Reset all locations to unvisited
            Object.keys(gameState.locations).forEach(key => {
                gameState.locations[key].visited = false;
                gameState.locations[key].scouted = false;
            });
            // Mark starting location as visited
            gameState.locations['3,2'].visited = true;

            // Reset inventory to starting items
            gameState.inventory = [
                { id: 'dagger', name: 'Dagger', type: 'weapon', damage: '1d4', equipped: true },
                { id: 'lockpicks', name: 'Lockpicks', type: 'tool', uses: 5 },
                { id: 'rope', name: 'Rope', type: 'tool', uses: 10 },
                { id: 'torch', name: 'Torch', type: 'light', uses: 8 }
            ];

            // Reset objectives
            gameState.objectives = [
                { id: 'obj1', text: 'Gather your party', completed: false },
                { id: 'obj2', text: 'Reach Emberpeak Mines', completed: false },
                { id: 'obj3', text: 'Rescue the trapped miners', completed: false },
                { id: 'obj4', text: 'Seal the shattered rune', completed: false }
            ];

            // Reset quest flags
            gameState.questFlags = {
                foundMinersNote: false,
                clearedRubble: false,
                rescuedMiners: false,
                foundSealingStone: false,
                sealedRune: false,
                talkedToSurvivor: false
            };

            // Re-render all UI
            renderCharacterStats();
            renderInventory();
            renderObjectives();
            updateMap();
            updateHP();
            updateLocationIndicator();
            updateContextualActions();

            // Clear adventure log and add welcome message
            const viewport = document.getElementById('viewport');
            viewport.innerHTML = '';
            addText('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━', 'quest');
            addText('⚔️ THE EMBERPEAK EXPEDITION ⚔️', 'quest');
            addText('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━', 'quest');
            addText('Welcome, brave adventurer!', 'quest');
            addText('Your quest: Rescue miners trapped beneath Emberpeak and seal the shattered rune.', 'quest');
            addText('', '');
            addText('You find yourself in a dimly lit tavern.', '');
            addText('The air is thick with pipe smoke and hushed conversations.', '');
            addText('Two seasoned adventurers sit at the bar - a cunning Rogue and a battle-hardened Fighter.', '');

            GameLogger.system('New game initialized', {
                location: gameState.currentLocation,
                hp: gameState.playerHP,
                inventory: gameState.inventory.length
            });
        }

        // ============================================================
        // END DATA-DRIVEN RENDER FUNCTIONS
        // ============================================================

        // Initialize map
        function initMap(containerId) {
            const mapContainer = document.getElementById(containerId);
            mapContainer.innerHTML = '';

            // Determine which region to show based on player location
            const currentLocationKey = `${gameState.currentLocation.x},${gameState.currentLocation.y}`;
            const currentLoc = gameState.locations[currentLocationKey];
            const isUnderground = currentLoc && currentLoc.region === 'underground';

            // Update region indicator if it exists (for modal)
            const regionIndicator = document.getElementById('region-indicator');
            if (regionIndicator) {
                if (isUnderground) {
                    regionIndicator.textContent = '⛏️ EMBERPEAK MINES - UNDERGROUND';
                    regionIndicator.classList.add('underground');
                } else {
                    regionIndicator.textContent = '🏰 SURFACE - TOWN & FOREST';
                    regionIndicator.classList.remove('underground');
                }
            }

            // Set Y range based on region
            const yStart = isUnderground ? 5 : 0;
            const yEnd = isUnderground ? 10 : 5;

            // Display map for current region only
            for (let y = yStart; y < yEnd; y++) {
                for (let x = 0; x < 7; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'map-cell unexplored';
                    cell.id = `${containerId}-${x}-${y}`;

                    const locationKey = `${x},${y}`;
                    const location = gameState.locations[locationKey];

                    if (location) {
                        // Mark underground locations
                        if (location.region === 'underground') {
                            cell.classList.add('underground');
                        }

                        // Add tooltip
                        const tooltip = document.createElement('div');
                        tooltip.className = 'map-tooltip';

                        if (location.visited) {
                            cell.classList.add('visited');
                            cell.classList.remove('unexplored');
                            cell.setAttribute('data-icon', location.icon);
                            tooltip.textContent = location.name;
                        } else if (location.scouted) {
                            cell.classList.add('scouted');
                            cell.classList.remove('unexplored');
                            cell.setAttribute('data-icon', location.icon);
                            tooltip.textContent = `${location.name} (Scouted)`;
                        } else {
                            tooltip.textContent = 'Unexplored';
                        }

                        cell.appendChild(tooltip);

                        // Add walls
                        if (location.walls) {
                            location.walls.forEach(wall => {
                                cell.classList.add(`wall-${wall}`);
                            });
                        }

                        // Current position
                        if (x === gameState.currentLocation.x && y === gameState.currentLocation.y) {
                            cell.classList.add('current');
                            cell.classList.remove('unexplored');
                            cell.classList.remove('scouted');
                            tooltip.textContent = `📍 ${location.name} (You are here)`;
                        }
                    }

                    mapContainer.appendChild(cell);
                }
            }
        }

        // Update map
        function updateMap() {
            // Re-initialize both maps to reflect new state
            initMap('map');
            initMap('map-modal-grid');

            // Highlight neighbors around current position in the center map
            const { x, y } = gameState.currentLocation;
            const neighbors = [
                { dx: 0, dy: -1, dir: 'north' },
                { dx: 0, dy: 1, dir: 'south' },
                { dx: 1, dy: 0, dir: 'east' },
                { dx: -1, dy: 0, dir: 'west' }
            ];

            const currentKey = `${x},${y}`;
            const currentLoc = gameState.locations[currentKey];
            neighbors.forEach(n => {
                const nx = x + n.dx; const ny = y + n.dy;
                const id = `map-${nx}-${ny}`;
                const el = document.getElementById(id);
                if (!el) return;
                // Skip if wall blocks this direction
                if (currentLoc?.walls?.includes(n.dir)) return;
                el.classList.add('neighbor');
                el.title = `Move ${n.dir}`;
                el.onclick = () => move(n.dir);
            });
        }

        // Update location indicator display
        function updateLocationIndicator() {
            const { x, y } = gameState.currentLocation;
            const locationKey = `${x},${y}`;
            const location = gameState.locations[locationKey];

            if (location) {
                const locationIndicator = document.getElementById('current-location');
                const locationIcon = locationIndicator.querySelector('.location-icon');
                const locationName = locationIndicator.querySelector('.location-name');

                locationIcon.textContent = location.icon || '📍';
                locationName.textContent = location.name;
            }
        }

        // Add text to viewport (Adventure Log)
        function addText(text, className = '') {
            const viewport = document.getElementById('viewport');
            const cursor = document.querySelector('.cursor');

            const line = document.createElement('div');
            line.className = 'text-line ' + className;
            line.textContent = text;

            viewport.insertBefore(line, cursor);

            // Limit message history to 100 lines to prevent memory issues
            const allLines = viewport.querySelectorAll('.text-line:not(.cursor)');
            if (allLines.length > 100) {
                allLines[0].remove();
            }

            viewport.scrollTop = viewport.scrollHeight;
        }

        // Add text to system console (Technical Log)
        function addSystemLog(text, type = 'info') {
            const console = document.getElementById('system-console');

            const line = document.createElement('div');
            line.className = 'system-log ' + type;

            // Add timestamp
            const timestamp = new Date().toLocaleTimeString('en-US', { hour12: false });
            line.textContent = `[${timestamp}] ${text}`;

            console.appendChild(line);

            // Limit message history to 200 lines for system console
            const allLines = console.querySelectorAll('.system-log');
            if (allLines.length > 200) {
                allLines[0].remove();
            }

            console.scrollTop = console.scrollHeight;
        }

        // Navigation
        function move(direction) {
            GameLogger.navigation(direction, gameState.currentLocation);

            // Prevent movement during combat
            if (gameState.inCombat) {
                addText("⚠️ You can't move during combat!", 'damage');
                GameLogger.action('Movement blocked', { reason: 'in combat' });
                return;
            }

            // Immediate feedback
            const directionSymbol = {
                'north': '⬆️',
                'south': '⬇️',
                'east': '➡️',
                'west': '⬅️'
            };
            addText(`${directionSymbol[direction]} Moving ${direction}...`, 'system');

            const { x, y } = gameState.currentLocation;
            const currentKey = `${x},${y}`;
            const currentLocation = gameState.locations[currentKey];

            // Check if there's a wall blocking this direction
            if (currentLocation && currentLocation.walls.includes(direction)) {
                addText(`❌ BLOCKED: There's a wall to the ${direction}!`, 'damage');
                addText(`You see: ${getWallDescription(direction)}`, 'damage');
                GameLogger.action('Movement blocked', { reason: 'wall', direction });
                return;
            }

            let newX = x, newY = y;

            switch(direction) {
                case 'north': newY--; break;
                case 'south': newY++; break;
                case 'east': newX++; break;
                case 'west': newX--; break;
            }

            const locationKey = `${newX},${newY}`;

            if (gameState.locations[locationKey]) {
                const previousLocation = gameState.locations[currentKey];
                const oldLocation = gameState.currentLocation;
                gameState.currentLocation = { x: newX, y: newY };
                const location = gameState.locations[locationKey];

                GameLogger.state('Location changed', gameState.currentLocation, oldLocation);
                GameLogger.action('Movement successful', {
                    from: previousLocation?.name,
                    to: location.name,
                    direction
                });

                // Check for region transition
                if (previousLocation && previousLocation.region !== location.region) {
                    GameLogger.action('Region transition', {
                        from: previousLocation.region,
                        to: location.region
                    });
                    if (location.region === 'underground') {
                        addText('━━━━━━━━━━━━━━━━━━━━', 'quest');
                        addText('⛏️ You descend into the darkness of Emberpeak Mines...', 'quest');
                        addText('The air grows cold. The light from above fades.', 'quest');
                        addText('━━━━━━━━━━━━━━━━━━━━', 'quest');

                        // Complete quest objective
                        if (!gameState.objectives[1].completed) {
                            completeObjective(1);
                        }
                    } else {
                        addText('━━━━━━━━━━━━━━━━━━━━', 'success');
                        addText('🌄 You ascend back to the surface...', 'success');
                        addText('Fresh air fills your lungs. Sunlight returns.', 'success');
                        addText('━━━━━━━━━━━━━━━━━━━━', 'success');
                    }
                }

                if (!location.visited) {
                    location.visited = true;
                    addText(`🗺️ You discover: ${location.name}!`, 'success');
                    GameLogger.action('Location discovered', { location: location.name, coordinates: locationKey });
                } else {
                    addText(`➡️ You move to: ${location.name}`);
                }

                addText(location.description);
                updateMap();
                updateContextualActions(); // Update available actions based on new location
                updateLocationIndicator(); // Update location display
                saveGameState(); // Auto-save after movement

                // Decrement cooldown
                if (gameState.encounterCooldown > 0) {
                    gameState.encounterCooldown--;
                }

                // Random encounter chance (15%, with cooldown)
                if (gameState.encounterCooldown === 0 &&
                    Math.random() < 0.15 &&
                    gameState.lastEncounterLocation !== locationKey) {
                    setTimeout(() => {
                        triggerEncounter();
                    }, 1000);
                }
            } else {
                addText("❌ You can't go that way - nothing but wilderness!", 'damage');
            }
        }

        // Get wall description
        function getWallDescription(direction) {
            const descriptions = {
                north: "Tall stone walls block the northern passage",
                south: "A thick barrier prevents travel south",
                east: "Rubble and debris block the eastern path",
                west: "Ancient walls seal off the western route"
            };
            return descriptions[direction] || "An impassable barrier";
        }

        // Trigger random encounter
        function triggerEncounter() {
            // Already in combat, skip
            if (gameState.inCombat) {
                GameLogger.combat('Encounter blocked', { reason: 'Already in combat' });
                return;
            }

            gameState.inCombat = true;
            GameLogger.state('Combat mode', true, false);

            const locationKey = `${gameState.currentLocation.x},${gameState.currentLocation.y}`;
            gameState.lastEncounterLocation = locationKey;

            const currentLocation = gameState.locations[locationKey];
            let encounters;

            // Different encounters based on region
            if (currentLocation && currentLocation.region === 'underground') {
                encounters = [
                    { text: "🦇 A swarm of cave bats attacks!", enemy: "Giant Bats", hp: 12 },
                    { text: "👹 A corrupted miner lurches toward you!", enemy: "Corrupted Miner", hp: 18 },
                    { text: "🕷️ A massive spider drops from the ceiling!", enemy: "Giant Spider", hp: 22 },
                    { text: "⚫ A shadow creature materializes from the darkness!", enemy: "Shadow Spawn", hp: 20 },
                    { text: "💀 An undead guardian rises from the stone!", enemy: "Stone Revenant", hp: 28 }
                ];
            } else {
                encounters = [
                    { text: "⚔️ A wild goblin appears!", enemy: "Goblin", hp: 15 },
                    { text: "💀 You spot a skeleton warrior!", enemy: "Skeleton", hp: 20 },
                    { text: "🗡️ An orc blocks your path!", enemy: "Orc", hp: 25 },
                    { text: "🐺 A dire wolf prowls from the shadows!", enemy: "Dire Wolf", hp: 17 }
                ];
            }

            const encounter = encounters[Math.floor(Math.random() * encounters.length)];

            // Log combat initiation
            GameLogger.combat('Combat initiated', {
                enemy: encounter.enemy,
                enemyHP: encounter.hp,
                playerHP: gameState.playerHP,
                location: locationKey,
                region: currentLocation?.region || 'surface'
            });

            addText('━━━━━━━━━━━━━━━━━━━━', 'combat');
            addText(encounter.text, 'combat');
            addText(`${encounter.enemy} HP: ${encounter.hp}`, 'combat');

            showCombatChoices(encounter);
            updateContextualActions(); // Update to show combat actions
        }

        // End combat
        function endCombat(result = 'unknown', details = {}) {
            GameLogger.combat('Combat ended', {
                result: result,
                playerHP: gameState.playerHP,
                remainingHP: details.remainingHP || null,
                xpGained: details.xpGained || 0,
                enemyDefeated: details.enemy || null
            });

            gameState.inCombat = false;
            GameLogger.state('Combat mode', false, true);

            gameState.encounterCooldown = 3; // 3 moves before next encounter can trigger
            addText('━━━━━━━━━━━━━━━━━━━━', 'success');
            updateContextualActions(); // Update to show non-combat actions
        }

        // Complete quest objective
        function completeObjective(index) {
            if (gameState.objectives[index] && !gameState.objectives[index].completed) {
                gameState.objectives[index].completed = true;
                renderObjectives();  // Re-render with new completed state
                addText(`🎯 Quest Updated: ${gameState.objectives[index].text}`, 'quest');
                saveGameState();  // Auto-save progress
            }
        }

        // Show combat choices
        function showCombatChoices(encounter) {
            const viewport = document.getElementById('viewport');

            // Remove any existing choice divs (bug fix for duplicates)
            const existingChoices = viewport.querySelectorAll('.choices');
            existingChoices.forEach(choice => choice.remove());

            const choicesDiv = document.createElement('div');
            choicesDiv.className = 'choices';

            const attackBtn = document.createElement('button');
            attackBtn.className = 'choice-button';
            attackBtn.textContent = 'Attack with your dagger';
            attackBtn.onclick = () => {
                const damage = Math.floor(Math.random() * 6) + 3;

                // Log player attack
                GameLogger.combat('Player attacked', {
                    damage: damage,
                    weapon: 'dagger',
                    enemyHPBefore: encounter.hp,
                    enemyHPAfter: encounter.hp - damage
                });

                addText(`⚔️ You strike for ${damage} damage!`, 'combat');
                encounter.hp -= damage;

                if (encounter.hp <= 0) {
                    // Victory!
                    GameLogger.combat('Enemy defeated', {
                        enemy: encounter.enemy,
                        xpGained: 50,
                        playerHP: gameState.playerHP
                    });

                    addText(`✅ ${encounter.enemy} defeated!`, 'success');
                    addText('💰 You gain 50 XP!', 'success');
                    choicesDiv.remove();
                    endCombat('victory', {
                        enemy: encounter.enemy,
                        xpGained: 50,
                        remainingHP: gameState.playerHP
                    });
                } else {
                    // Enemy counter-attack
                    addText(`${encounter.enemy} HP: ${encounter.hp}`, 'combat');
                    const enemyDamage = Math.floor(Math.random() * 4) + 1;

                    GameLogger.combat('Enemy attacked', {
                        enemy: encounter.enemy,
                        damage: enemyDamage,
                        playerHPBefore: gameState.playerHP,
                        playerHPAfter: gameState.playerHP - enemyDamage
                    });

                    addText(`🗡️ ${encounter.enemy} attacks back for ${enemyDamage} damage!`, 'damage');
                    updateHP(gameState.playerHP - enemyDamage);

                    // If still alive, keep showing combat choices
                    if (gameState.playerHP > 0) {
                        choicesDiv.remove();
                        showCombatChoices(encounter);
                    } else {
                        // Player died
                        GameLogger.combat('Player defeated', {
                            enemy: encounter.enemy,
                            finalHP: 0
                        });

                        addText('💀 You have been defeated...', 'damage');
                        choicesDiv.remove();
                        endCombat('defeat', {
                            enemy: encounter.enemy,
                            remainingHP: 0
                        });
                    }
                }
            };

            const skillBtn = document.createElement('button');
            skillBtn.className = 'choice-button';
            skillBtn.textContent = 'Attempt to sneak past (DEX check)';
            skillBtn.onclick = () => {
                const roll = Math.floor(Math.random() * 20) + 1;
                const total = roll + 4; // DEX modifier

                GameLogger.combat('Sneak attempt', {
                    roll: roll,
                    modifier: 4,
                    total: total,
                    dc: 12,
                    success: total >= 12
                });

                addText(`🎲 You roll ${roll} + 4 (DEX) = ${total}`, 'success');

                if (total >= 12) {
                    // Successful sneak
                    GameLogger.combat('Sneak successful', {
                        enemy: encounter.enemy,
                        playerHP: gameState.playerHP
                    });

                    addText('✅ Success! You slip past unnoticed.', 'success');
                    choicesDiv.remove();
                    endCombat('escaped', {
                        enemy: encounter.enemy,
                        remainingHP: gameState.playerHP
                    });
                } else {
                    // Failed sneak
                    GameLogger.combat('Sneak failed', {
                        enemy: encounter.enemy,
                        damage: 'incoming'
                    });

                    addText('❌ Failed! Combat is inevitable!', 'damage');
                    const enemyDamage = Math.floor(Math.random() * 4) + 1;

                    GameLogger.combat('Enemy attacked (sneak punishment)', {
                        enemy: encounter.enemy,
                        damage: enemyDamage,
                        playerHPBefore: gameState.playerHP,
                        playerHPAfter: gameState.playerHP - enemyDamage
                    });

                    addText(`🗡️ ${encounter.enemy} attacks for ${enemyDamage} damage!`, 'damage');
                    updateHP(gameState.playerHP - enemyDamage);

                    // Failed sneak = forced into combat
                    if (gameState.playerHP > 0) {
                        choicesDiv.remove();
                        showCombatChoices(encounter);
                    } else {
                        GameLogger.combat('Player defeated (failed sneak)', {
                            enemy: encounter.enemy,
                            finalHP: 0
                        });

                        addText('💀 You have been defeated...', 'damage');
                        choicesDiv.remove();
                        endCombat('defeat', {
                            enemy: encounter.enemy,
                            remainingHP: 0
                        });
                    }
                }
            };

            choicesDiv.appendChild(attackBtn);
            choicesDiv.appendChild(skillBtn);
            viewport.appendChild(choicesDiv);
        }

        // Update HP
        function updateHP(newHP = null) {
            // If newHP provided, update gameState; otherwise just refresh display
            if (newHP !== null) {
                gameState.playerHP = Math.max(0, Math.min(newHP, gameState.maxHP));
            }

            const hpBar = document.getElementById('hp-bar');
            const hpText = document.getElementById('hp-text');
            const percent = (gameState.playerHP / gameState.maxHP) * 100;

            hpBar.style.width = percent + '%';
            hpText.textContent = `${gameState.playerHP} / ${gameState.maxHP} HP`;

            hpBar.className = 'hp-bar';
            if (percent < 25) hpBar.classList.add('critical');
            else if (percent < 50) hpBar.classList.add('low');

            if (gameState.playerHP <= 0) {
                addText('You have been defeated!', 'damage');
                addText('Game Over. Refresh to try again.', 'damage');
            }
        }

        // Modal functions
        function openModal(modalId) {
            document.getElementById(modalId).classList.add('active');
        }

        function closeModal(modalId) {
            document.getElementById(modalId).classList.remove('active');
        }

        function openNPCModal(locationKey, linesOverride = null) {
            const body = document.getElementById('npc-modal-body');
            const lines = linesOverride || locationDialogues[locationKey] || ["No one seems interested in talking right now."];
            body.innerHTML = lines.map(l => `<div style="margin: 6px 0;">${l}</div>`).join('');
            openModal('npc-modal');
        }

        // Location-based dialogues
        const locationDialogues = {
            '3,2': [ // Starting Tavern
                "💬 The Fighter nods: 'We should head to the mines soon.'",
                "💬 The Rogue whispers: 'I heard strange sounds from the east...'",
                "💬 The innkeeper warns: 'Dangerous times, dangerous roads.'",
                "💬 A stranger mutters: 'The rune... it calls to me...'"
            ],
            '3,1': [ // Town Square
                "💬 A guard says: 'The market's been busy today.'",
                "💬 A merchant shouts: 'Fresh supplies! Get them while they last!'",
                "💬 A child tugs your sleeve: 'Have you seen my cat?'"
            ],
            '4,2': [ // Market Street
                "💬 A vendor smiles: 'Quality goods at fair prices!'",
                "💬 The weaponsmith grunts: 'Could forge you something special...'",
                "💬 A trader warns: 'Roads to the east are dangerous lately.'"
            ],
            '2,2': [ // Blacksmith
                "💬 The blacksmith hammers steel: 'Need something sharp?'",
                "💬 He wipes sweat: 'Been forging weapons day and night...'",
                "💬 'Strange orders coming in. Dark times ahead.'"
            ],
            '3,3': [ // City Gates
                "💬 The gate guard: 'Be careful out there, adventurer.'",
                "💬 'Many enter the forest. Few return.'",
                "💬 'If you see trouble, run back here quickly.'"
            ],
            // UNDERGROUND DIALOGUES
            '3,5': [ // Mine Entrance
                "💬 Echoes of pickaxes fade into silence...",
                "💬 You notice fresh bootprints leading deeper.",
                "💬 A warning sign: 'DANGER - Unstable tunnels ahead'"
            ],
            '3,6': [ // Shaft Junction
                "💬 Distant screams echo from the depths.",
                "💬 You hear dripping water and... something else.",
                "💬 Tool marks suggest the miners fled in panic."
            ],
            '2,6': [ // Crystal Cavern
                "💬 The crystals hum with strange energy.",
                "💬 You feel... watched. The shadows move wrong.",
                "💬 Beautiful, but unnatural. This wasn't here before."
            ],
            '3,7': [ // Mining Camp
                "💬 A journal lies open: 'Day 12 - The rune... it whispers...'",
                "💬 Dried blood stains the ground. Not much.",
                "💬 Supplies remain. They left everything behind."
            ],
            '2,7': [ // Collapsed Tunnel
                "💬 You hear faint tapping from beyond the rubble!",
                "💬 Survivors? Or something else?",
                "💬 The collapse looks... deliberate. Something broke through."
            ],
            '3,8': [ // Deep Chamber
                "💬 An ancient presence stirs in the darkness.",
                "💬 Your torch flickers. Something doesn't want light here.",
                "💬 The walls are carved with warnings in old languages."
            ],
            '3,9': [ // Rune Chamber
                "💬 The rune pulses like a beating heart.",
                "💬 Power radiates from the shattered fragments.",
                "💬 This is the source. Seal it, and the mines are safe."
            ]
        };

        // Action buttons (only if they exist - they may be dynamically created)
        const talkBtn = document.getElementById('talk-btn');
        if (talkBtn) {
            talkBtn.onclick = () => {
                if (gameState.inCombat) {
                    addText("⚠️ Not a great time for chatting!", 'damage');
                    return;
                }

                // Immediate feedback
                addText("💬 You initiate a conversation...", 'system');

                const locationKey = `${gameState.currentLocation.x},${gameState.currentLocation.y}`;
                setTimeout(() => {
                    handleQuestInteraction(locationKey);
                }, 200); // Small delay for realism
            };
        }

        // Quest interaction handler
        function handleQuestInteraction(locationKey) {
            // MINING CAMP (3,7) - Find Miner's Note
            if (locationKey === '3,7' && !gameState.questFlags.foundMinersNote) {
                addText('━━━━━━━━━━━━━━━━━━━━', 'quest');
                addText('🔍 You search the abandoned camp...', '');
                addText('Among the scattered belongings, you find a bloodstained note.', '');
                addText('📜 Item Found: Miner\'s Note', 'success');
                addText('━━━━━━━━━━━━━━━━━━━━', 'quest');
                addItemByName('Miner\'s Note', 'quest');
                gameState.questFlags.foundMinersNote = true;
                return;
            }

            // COLLAPSED TUNNEL (2,7) - Rescue Miners
            if (locationKey === '2,7') {
                if (!gameState.questFlags.clearedRubble) {
                    if (hasItem('Rope')) {
                        addText('━━━━━━━━━━━━━━━━━━━━', 'quest');
                        addText('⚒️ You use your rope and tools to create a pulley system...', '');
                        addText('*CRASH* The rubble shifts! You hear voices!', 'success');
                        addText('"Help! Is someone there?!"', 'success');
                        gameState.questFlags.clearedRubble = true;
                        addText('━━━━━━━━━━━━━━━━━━━━', 'quest');
                    } else {
                        addText('🪨 The rubble is too heavy to move by hand...', 'damage');
                        addText('You need proper equipment. Maybe rope could help?', '');
                    }
                } else if (!gameState.questFlags.rescuedMiners) {
                    addText('━━━━━━━━━━━━━━━━━━━━', 'quest');
                    addText('👷 "Thank the gods! We thought we were done for!"', 'success');
                    addText('👷 Foreman Garrett: "Seven days trapped... we found something strange down here."', 'success');
                    addText('👷 "A glowing stone in the deep chamber. The elders said it can seal dark magic."', 'success');
                    addText('👷 "Take it - seal that cursed rune before more miners die!"', 'success');
                    addText('💠 Quest Item: Sealing Stone (check Deep Chamber)', 'quest');
                    addText('🧪 The miners give you a Healing Potion in thanks!', 'success');
                    addText('━━━━━━━━━━━━━━━━━━━━', 'quest');
                    addItemByName('Healing Potion', 'potion');
                    gameState.questFlags.rescuedMiners = true;
                    gameState.questFlags.talkedToSurvivor = true;
                    completeObjective(2); // Quest 3: Rescue the trapped miners
                } else {
                    addText('👷 "Get to the Deep Chamber and find that stone! Hurry!"', 'success');
                }
                return;
            }

            // DEEP CHAMBER (3,8) - Find Sealing Stone
            if (locationKey === '3,8' && gameState.questFlags.rescuedMiners && !gameState.questFlags.foundSealingStone) {
                addText('━━━━━━━━━━━━━━━━━━━━', 'quest');
                addText('🔍 You search the massive cavern...', '');
                addText('In an alcove, resting on an ancient pedestal, you see it:', '');
                addText('💠 A stone pulsing with blue containment magic!', 'success');
                addText('Item Found: Sealing Stone', 'success');
                addText('━━━━━━━━━━━━━━━━━━━━', 'quest');
                addItemByName('Sealing Stone', 'quest');
                gameState.questFlags.foundSealingStone = true;
                return;
            }

            // RUNE CHAMBER (3,9) - Seal the Rune (Final Quest)
            if (locationKey === '3,9') {
                if (hasItem('Sealing Stone') && !gameState.questFlags.sealedRune) {
                    addText('━━━━━━━━━━━━━━━━━━━━', 'quest');
                    addText('✨ The shattered rune pulses with malevolent energy...', 'damage');
                    addText('💠 You hold up the Sealing Stone. It begins to glow!', 'success');
                    addText('Ancient dwarven runes appear in the air around you.', 'success');
                    addText('The stone\'s magic flows into the corrupted rune...', 'success');
                    addText('*BOOM* A blinding flash! The dark energy dissipates!', 'success');
                    addText('━━━━━━━━━━━━━━━━━━━━', 'quest');
                    addText('🎉 The rune is sealed! The mines are safe!', 'success');
                    addText('━━━━━━━━━━━━━━━━━━━━', 'quest');
                    gameState.questFlags.sealedRune = true;
                    completeObjective(3); // Quest 4: Seal the shattered rune
                    // Remove Sealing Stone from inventory (consumed)
                    removeItemByName('Sealing Stone');
                } else if (gameState.questFlags.sealedRune) {
                    addText('✨ The sealed rune hums peacefully. Your quest is complete.', 'success');
                } else {
                    addText('✨ The rune pulses with dark energy. You need the Sealing Stone!', 'damage');
                }
                return;
            }

            // Default: Check for regular dialogues
            const dialogues = locationDialogues[locationKey];
            if (dialogues) {
                const dialogue = dialogues[Math.floor(Math.random() * dialogues.length)];
                addText(dialogue, 'success');

                // First time talking in tavern = complete first objective
                if (locationKey === '3,2' && !gameState.objectives[0].completed) {
                    completeObjective(0);
                }
            } else {
                addText("💬 Nothing of interest here. Try exploring!", '');
            }
        }

        const attackBtn = document.getElementById('attack-btn');
        if (attackBtn) {
            attackBtn.onclick = () => {
                addText("⚔️ Preparing to attack...", 'combat');  // Immediate feedback
                setTimeout(() => {
                    addText("There's nothing to attack here. Try moving to find encounters!", 'damage');
                }, 200);
            };
        }

        const skillBtn = document.getElementById('skill-btn');
        if (skillBtn) {
            skillBtn.onclick = () => {
            if (gameState.inCombat) {
                addText("⚠️ You're too busy fighting!", 'damage');
                return;
            }

            addText("🎲 Rolling skill check...", 'system');  // Immediate feedback
            setTimeout(() => {
                const roll = Math.floor(Math.random() * 20) + 1;
                const skills = ['Perception', 'Investigation', 'Stealth', 'Sleight of Hand'];
                const skill = skills[Math.floor(Math.random() * skills.length)];
                const bonus = Math.floor(Math.random() * 5) + 1;
                const total = roll + bonus;

            addText(`${skill} Check: d20(${roll}) + ${bonus} = ${total}`, 'success');

            if (total >= 15) {
                // Critical success - reveal adjacent locations
                const { x, y } = gameState.currentLocation;
                const adjacent = [
                    { x: x, y: y - 1, dir: 'north' },
                    { x: x, y: y + 1, dir: 'south' },
                    { x: x + 1, y: y, dir: 'east' },
                    { x: x - 1, y: y, dir: 'west' }
                ];

                let revealed = false;
                adjacent.forEach(pos => {
                    const key = `${pos.x},${pos.y}`;
                    if (gameState.locations[key] && !gameState.locations[key].visited) {
                        addText(`🔍 Critical Success! You spot ${gameState.locations[key].name} to the ${pos.dir}!`, 'success');
                        gameState.locations[key].scouted = true;  // Mark as scouted
                        revealed = true;
                    }
                });

                if (revealed) {
                    updateMap();  // Refresh map to show scouted locations
                } else {
                    addText('🔍 You search carefully but find nothing new nearby.', 'success');
                }

            } else if (total >= 10) {
                // Success - get info about current location
                const locationKey = `${gameState.currentLocation.x},${gameState.currentLocation.y}`;
                const location = gameState.locations[locationKey];
                const currentLocation = gameState.locations[locationKey];

                if (currentLocation && currentLocation.walls.length > 0) {
                    const wallDirs = currentLocation.walls.join(', ');
                    addText(`👁️ You notice walls blocking paths to: ${wallDirs}`, 'success');
                } else {
                    addText('👁️ You notice the area seems safe to explore.', 'success');
                }

            } else {
                addText('You find nothing of note.', '');
            }
            }, 300); // End setTimeout for skill check
            };
        }

        const restBtn = document.getElementById('rest-btn');
        if (restBtn) {
            restBtn.onclick = () => {
                const healed = Math.min(gameState.maxHP - gameState.playerHP, 20);
                updateHP(gameState.playerHP + healed);
                addText(`You take a short rest and recover ${healed} HP.`, 'success');
            };
        }

        document.getElementById('examine').onclick = () => {
            GameLogger.button('EXAMINE', { location: gameState.currentLocation });
            const key = `${gameState.currentLocation.x},${gameState.currentLocation.y}`;
            const location = gameState.locations[key];
            if (location) {
                GameLogger.action('Examining location', { location: location.name, key });
                addText(`👁 You look around...`, 'system');  // Immediate feedback
                setTimeout(() => {
                    addText(`You examine ${location.name}...`);
                    addText(location.description);
                    updateContextualActions(); // Refresh available actions
                }, 200); // Small delay for realism
            }
        };

        // Navigation buttons
        document.getElementById('north').onclick = () => {
            GameLogger.button('NORTH', { from: gameState.currentLocation });
            move('north');
        };
        document.getElementById('south').onclick = () => {
            GameLogger.button('SOUTH', { from: gameState.currentLocation });
            move('south');
        };
        document.getElementById('east').onclick = () => {
            GameLogger.button('EAST', { from: gameState.currentLocation });
            move('east');
        };
        document.getElementById('west').onclick = () => {
            GameLogger.button('WEST', { from: gameState.currentLocation });
            move('west');
        };

        // ============================================================
        // CONTEXTUAL ACTIONS
        // ============================================================

        // Update contextual actions based on current location/state
        function updateContextualActions() {
            const container = document.getElementById('contextual-actions');
            container.innerHTML = '';

            const key = `${gameState.currentLocation.x},${gameState.currentLocation.y}`;
            const location = gameState.locations[key];

            // Combat-specific actions
            if (gameState.inCombat) {
                addContextAction('⚔️ ATTACK', () => {
                    GameLogger.action('Context action: ATTACK', { inCombat: true });
                    addText("⚔️ Preparing to attack...", 'combat');
                    setTimeout(() => {
                        addText("There's nothing to attack here. Try moving to find encounters!", 'damage');
                    }, 200);
                });
                addContextAction('🎯 SKILL CHECK', () => {
                    GameLogger.action('Context action: SKILL CHECK', { inCombat: true });
                    addText("🎲 Rolling skill check...", 'system');
                });
                addContextAction('🛌 REST', () => {
                    GameLogger.action('Context action: REST', { inCombat: true });
                    addText("💤 You take a short rest...", 'system');
                });
                return;
            }

            // Location-specific actions
            if (location) {
                if (location.npc) {
                    addContextAction('💬 TALK', () => {
                        GameLogger.action('Context action: TALK', { location: location.name, npc: location.npc });
                        if (gameState.inCombat) {
                            addText("⚠️ Not a great time for chatting!", 'damage');
                            return;
                        }
                        addText("💬 You initiate a conversation...", 'system');
                        const locationKey = `${gameState.currentLocation.x},${gameState.currentLocation.y}`;
                        openNPCModal(locationKey);
                    });
                }

                if (location.items && location.items.length > 0) {
                    addContextAction('🔍 SEARCH', () => {
                        addText(`You search ${location.name}...`);
                        addText(`You find: ${location.items.join(', ')}`, 'success');
                    });
                }

                if (location.locked) {
                    addContextAction('🔓 PICK LOCK', () => {
                        addText('You attempt to pick the lock...', '');
                        const roll = rollDice(20) + 4; // DEX modifier
                        if (roll >= 15) {
                            addText(`🎯 Success! (Rolled ${roll})`, 'success');
                            location.locked = false;
                        } else {
                            addText(`❌ Failed! (Rolled ${roll})`, 'damage');
                        }
                    });
                }
            }

            // Always available actions
            addContextAction('👁 EXAMINE', () => {
                GameLogger.action('Context action: EXAMINE (always available)');
                const btn = document.getElementById('examine');
                if (btn) btn.click();
            });
            // Only add TALK/ATTACK when appropriate; otherwise disable with tooltip
            if (location && location.npc) {
                addContextAction('💬 TALK', () => {
                    GameLogger.action('Context action: TALK', { location: location.name, npc: location.npc });
                    if (gameState.inCombat) {
                        addText("⚠️ Not a great time for chatting!", 'damage');
                        return;
                    }
                    addText("💬 You initiate a conversation...", 'system');
                    const locationKey = `${gameState.currentLocation.x},${gameState.currentLocation.y}`;
                    openNPCModal(locationKey);
                });
            } else {
                const btn = addContextAction('💬 TALK', () => {});
                btn.disabled = true;
                btn.title = 'No one to talk to here';
            }

            if (gameState.inCombat) {
                addContextAction('⚔️ ATTACK', () => {
                    GameLogger.action('Context action: ATTACK', { inCombat: true });
                    addText("⚔️ Preparing to attack...", 'combat');
                    setTimeout(() => {
                        addText("You strike at your foe!", 'combat');
                    }, 200);
                });
            } else {
                const btn = addContextAction('⚔️ ATTACK', () => {});
                btn.disabled = true;
                btn.title = 'No enemies present';
            }
        }

        function addContextAction(label, callback) {
            const button = document.createElement('button');
            button.className = 'context-button';
            button.textContent = label;
            button.onclick = callback;
            document.getElementById('contextual-actions').appendChild(button);
            return button;
        }

        // Mobile modal buttons
        document.getElementById('mobile-map-btn').onclick = () => openModal('map-modal');
        document.getElementById('mobile-inv-btn').onclick = () => {
            // Populate inventory modal
            const invModal = document.getElementById('inventory-modal');
            invModal.innerHTML = document.getElementById('inventory').innerHTML;
            openModal('inv-modal');
        };
        document.getElementById('mobile-char-btn').onclick = () => openModal('char-modal');

        // Close buttons
        document.getElementById('close-map').onclick = () => closeModal('map-modal');
        document.getElementById('close-inv').onclick = () => closeModal('inv-modal');
        document.getElementById('close-char').onclick = () => closeModal('char-modal');
        document.getElementById('close-item').onclick = () => closeModal('item-modal');

        // Show item details
        function showItemDetails(itemName) {
            const item = itemDatabase[itemName];
            if (!item) return;

            let statsHTML = '';

            // Build stats based on item type
            if (item.damage) {
                statsHTML += `
                    <div class="item-stat-row">
                        <span class="item-stat-label">Damage:</span>
                        <span class="item-stat-value">${item.damage} ${item.damageType}</span>
                    </div>`;
            }

            if (item.bonus) {
                statsHTML += `
                    <div class="item-stat-row">
                        <span class="item-stat-label">Bonus:</span>
                        <span class="item-stat-value">${item.bonus} to ${item.skill}</span>
                    </div>`;
            }

            if (item.lightRadius) {
                statsHTML += `
                    <div class="item-stat-row">
                        <span class="item-stat-label">Light:</span>
                        <span class="item-stat-value">${item.lightRadius}</span>
                    </div>`;
            }

            if (item.duration) {
                statsHTML += `
                    <div class="item-stat-row">
                        <span class="item-stat-label">Duration:</span>
                        <span class="item-stat-value">${item.duration}</span>
                    </div>`;
            }

            if (item.capacity) {
                statsHTML += `
                    <div class="item-stat-row">
                        <span class="item-stat-label">Capacity:</span>
                        <span class="item-stat-value">${item.capacity}</span>
                    </div>`;
            }

            statsHTML += `
                <div class="item-stat-row">
                    <span class="item-stat-label">Weight:</span>
                    <span class="item-stat-value">${item.weight}</span>
                </div>
                <div class="item-stat-row">
                    <span class="item-stat-label">Value:</span>
                    <span class="item-stat-value">${item.value}</span>
                </div>`;

            if (item.properties) {
                statsHTML += `
                    <div class="item-stat-row">
                        <span class="item-stat-label">Properties:</span>
                        <span class="item-stat-value">${item.properties.join(', ')}</span>
                    </div>`;
            }

            const detailHTML = `
                <div class="item-detail-header">
                    <div class="item-detail-icon">${item.icon}</div>
                    <div class="item-detail-title">
                        <div class="item-detail-name">${item.name}</div>
                        <div class="item-detail-type">${item.type}</div>
                    </div>
                </div>

                <div class="item-image-section" id="item-image-section-${itemName.replace(/\s+/g, '-')}">
                    <div class="item-image-container">
                        <img id="item-generated-image-${itemName.replace(/\s+/g, '-')}" class="item-generated-image" style="display:none;" alt="${item.name}">
                        <div id="item-image-loading-${itemName.replace(/\s+/g, '-')}" class="item-image-loading" style="display:none;">
                            🍌 Generating ${item.name} artwork...
                        </div>
                        <div id="item-image-placeholder-${itemName.replace(/\s+/g, '-')}" class="item-image-placeholder">
                            <div class="item-image-icon">${item.icon}</div>
                            <div class="item-image-text">Click "Generate Image" to create AI artwork</div>
                        </div>
                    </div>
                    <button class="item-action-btn" style="margin-top: 10px; background: linear-gradient(to bottom, #404000, #202000); border-color: #ff0; color: #ff0;"
                            onclick="generateItemImageForModal('${itemName}')">
                        🍌 Generate New Image
                    </button>

                    <!-- Custom Prompt Section -->
                    <div class="custom-prompt-section" id="custom-prompt-section-${itemName.replace(/\s+/g, '-')}">
                        <div class="custom-prompt-header" onclick="toggleCustomPromptSection('${itemName}')">
                            <span class="custom-prompt-title">🎨 Customize Image Style</span>
                            <span class="custom-prompt-toggle" id="custom-prompt-toggle-${itemName.replace(/\s+/g, '-')}">▼</span>
                        </div>
                        <div class="custom-prompt-content" id="custom-prompt-content-${itemName.replace(/\s+/g, '-')}">
                            <div class="custom-prompt-helper">
                                Add custom details (e.g., "glowing", "ornate", "covered in runes", "ancient")
                            </div>
                            <textarea
                                class="custom-prompt-textarea"
                                id="custom-prompt-input-${itemName.replace(/\s+/g, '-')}"
                                placeholder="Add your custom style details here..."
                                maxlength="200"
                                oninput="updateCustomPromptPreview('${itemName}')"></textarea>
                            <div class="custom-prompt-counter">
                                <span style="color: #0a0;">Character count:</span>
                                <span class="char-count" id="char-count-${itemName.replace(/\s+/g, '-')}">0/200</span>
                            </div>
                            <div id="validation-message-${itemName.replace(/\s+/g, '-')}"></div>
                            <div class="prompt-preview-section">
                                <div class="prompt-preview-label">📝 Preview Final Prompt:</div>
                                <div class="prompt-preview-text" id="prompt-preview-${itemName.replace(/\s+/g, '-')}">
                                    <span class="prompt-preview-base">Default prompt will appear here</span>
                                </div>
                            </div>
                            <div class="custom-prompt-buttons">
                                <button class="custom-prompt-btn" onclick="clearCustomPrompt('${itemName}')">Clear</button>
                                <button class="custom-prompt-btn" onclick="applyCustomPrompt('${itemName}')">Apply to Next Generation</button>
                            </div>
                        </div>
                    </div>

                    <!-- Image Gallery -->
                    <div class="image-gallery" id="image-gallery-${itemName.replace(/\s+/g, '-')}">
                        <div class="gallery-header">
                            <span class="gallery-title">📸 Image Library</span>
                            <span class="gallery-count" id="gallery-count-${itemName.replace(/\s+/g, '-')}">0 images</span>
                        </div>
                        <div class="gallery-grid" id="gallery-grid-${itemName.replace(/\s+/g, '-')}">
                            <!-- Thumbnails will be injected here -->
                        </div>
                        <div class="gallery-pagination" id="gallery-pagination-${itemName.replace(/\s+/g, '-')}">
                            <!-- Pagination will be injected here -->
                        </div>
                    </div>
                </div>

                <div class="item-detail-stats">
                    ${statsHTML}
                </div>

                <div class="item-description">${item.description}</div>

                ${item.special ? `<div class="item-description" style="color: #ff0; border-top: 1px solid #0a0; padding-top: 10px;">
                    <strong>Special:</strong> ${item.special}
                </div>` : ''}

                <div class="item-actions">
                    <button class="item-action-btn" onclick="closeModal('item-modal')">Close</button>
                    <button class="item-action-btn" disabled>Use (Not Implemented)</button>
                    <button class="item-action-btn" disabled>Drop (Not Implemented)</button>
                </div>
            `;

            document.getElementById('item-detail-content').innerHTML = detailHTML;
            openModal('item-modal');

            // Load existing images in gallery
            renderImageGallery(itemName);

            // Initialize custom prompt preview
            updateCustomPromptPreview(itemName);
        }

        // Update inventory display
        function updateInventory() {
            // Update both sidebar and modal inventories
            ['inventory', 'inventory-modal'].forEach(containerId => {
                const inventoryContainer = document.getElementById(containerId);
                if (!inventoryContainer) return;

                inventoryContainer.innerHTML = '';

                gameState.inventory.forEach(itemName => {
                    const item = itemDatabase[itemName];
                    if (!item) return;

                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'inventory-item';
                    itemDiv.onclick = () => showItemDetails(itemName);

                    const nameDiv = document.createElement('div');
                    nameDiv.className = 'item-name';
                    nameDiv.textContent = itemName;

                    const descDiv = document.createElement('div');
                    descDiv.className = 'item-desc';

                    // Set description based on item type
                    if (item.damage) {
                        descDiv.textContent = `${item.damage} damage`;
                    } else if (item.bonus) {
                        descDiv.textContent = `${item.bonus} ${item.skill || 'bonus'}`;
                    } else if (item.healing) {
                        descDiv.textContent = `Heals ${item.healing} HP`;
                    } else if (item.lightRadius) {
                        descDiv.textContent = 'Light source';
                    } else if (item.type.includes('Quest')) {
                        descDiv.textContent = '⭐ Quest Item';
                    } else {
                        descDiv.textContent = 'Useful tool';
                    }

                    itemDiv.appendChild(nameDiv);
                    itemDiv.appendChild(descDiv);
                    inventoryContainer.appendChild(itemDiv);
                });
            });
        }

        // ============================================================
        // INITIALIZATION
        // ============================================================

        // Try to load saved game, or start fresh
        if (!loadGameState()) {
            // No save found - render initial state
            renderCharacterStats();
            renderInventory();
            renderObjectives();
        }

        // Update location indicator on page load
        updateLocationIndicator();

        // Close modals on background click
        window.onclick = (event) => {
            if (event.target.classList.contains('modal')) {
                event.target.classList.remove('active');
            }
        };

        // Initialize
        initMap('map');
        initMap('map-modal-grid');
        updateContextualActions(); // Initialize contextual actions
        addText('━━━━━━━━━━━━━━━━━━━━', 'success');
        addText('🎮 Use the NAVIGATION buttons to explore!', 'success');
        addText('💬 Click TALK to speak with NPCs.', 'success');
        addText('⚔️ Encounters will happen as you explore.', 'success');
        addText('━━━━━━━━━━━━━━━━━━━━', 'success');

        // ============================================================
        // INITIALIZE NANO BANANA IMAGE GENERATION
        // ============================================================

        // Generate the initial Emberpeak entrance scene
        async function initializeSceneViewer() {
            console.log('🍌 Initializing Nano Banana Scene Viewer...');

            const location = 'emberpeak_entrance';
            const timeOfDay = 'dawn';
            const weather = 'clear';

            // 1. CHECK CACHE FIRST
            const cachedScene = nanoBanana.sceneCache.get(location, timeOfDay, weather);
            if (cachedScene) {
                console.log('📦 Loading scene from cache (no API call needed)');
                addSystemLog('📦 Loading scene from cache (no API call needed)', 'cache');
                nanoBanana.displayImage(cachedScene.imageData);
                addText('📦 Loaded cached scene - no generation needed!', 'success');
                return;
            }

            // 2. Check if backend server is available
            const isHealthy = await nanoBanana.checkHealth();

            if (!isHealthy) {
                console.warn('⚠️ Nano Banana server not available. Using fallback art.');
                nanoBanana.showFallbackArt('entrance to Emberpeak, a mountain village at dawn');
                addText('🍌 Image generation offline. Using ASCII art.', 'info');
                return;
            }

            // 3. Generate NEW scene (only if not cached)
            console.log('🍌 No cached scene found - checking database or generating');
            addSystemLog('🍌 No cached scene found - checking database or generating', 'info');
            const scenePrompt = 'the entrance to Emberpeak, a mountain village at dawn. Stone archway covered in moss, cobblestone path, misty mountain peaks in background, warm torchlight. Fantasy RPG setting, atmospheric lighting.';

            addText('🍌 Loading scene from backend...', 'info');
            const result = await nanoBanana.generateSceneImage(scenePrompt, {
                subjectName: 'Emberpeak Entrance',
                style: 'photorealistic',
                aspectRatio: '16:9'
            });

            if (result) {
                // 4. CACHE the generated scene
                nanoBanana.sceneCache.set(location, result, timeOfDay, weather, scenePrompt);
                addText('✅ Scene generated and cached!', 'success');
                console.log('✅ Initial scene loaded and cached successfully');
                addSystemLog('✅ Initial scene loaded and cached successfully', 'success');
            } else {
                // Don't spam error messages - fallback art already shown
                if (nanoBanana.quotaExhausted) {
                    addText('⚠️ API quota exceeded. Using ASCII art fallback.', 'info');
                } else {
                    addText('⚠️ Scene generation unavailable. Using ASCII art.', 'info');
                }
            }
        }

        // Start scene generation after a short delay to let UI load
        setTimeout(() => {
            initializeSceneViewer();
        }, 1000);

        // ============================================================
        // END NANO BANANA INITIALIZATION
        // ============================================================

        // ============================================================
        // ITEM IMAGE GENERATION
        // ============================================================

        async function generateItemImageForModal(itemName) {
            const item = itemDatabase[itemName];
            if (!item) {
                console.error(`Item not found: ${itemName}`);
                return;
            }

            const safeItemName = itemName.replace(/\s+/g, '-');
            const imageEl = document.getElementById(`item-generated-image-${safeItemName}`);
            const loadingEl = document.getElementById(`item-image-loading-${safeItemName}`);
            const placeholderEl = document.getElementById(`item-image-placeholder-${safeItemName}`);

            // Show loading state
            if (placeholderEl) placeholderEl.style.display = 'none';
            if (imageEl) imageEl.style.display = 'none';
            if (loadingEl) loadingEl.style.display = 'block';

            // Build detailed prompt for the item
            const basePrompt = buildBasePrompt(item);

            // Check for custom prompt
            const customPrompt = customPrompts[itemName] || '';

            // Build final prompt
            let prompt = basePrompt;
            if (customPrompt.trim()) {
                prompt += customPrompt + '. ';
            }
            prompt += 'Fantasy RPG item, detailed illustration on neutral background, studio lighting, high quality.';

            console.log(`🍌 Generating image for: ${itemName}`);
            console.log(`📝 Prompt: ${prompt}`);
            addSystemLog(`🍌 Generating image for: ${itemName}`, 'api');
            if (customPrompt) {
                console.log(`🎨 Custom: "${customPrompt}"`);
                addSystemLog(`🎨 Custom prompt: "${customPrompt}"`, 'info');
            }

            // Skip if generation is disabled or quota exhausted
            if (nanoBanana.disabled || nanoBanana.quotaExhausted) {
                if (loadingEl) loadingEl.style.display = 'none';
                if (placeholderEl) {
                    placeholderEl.style.display = 'block';
                    placeholderEl.innerHTML = `
                        <div class="item-image-icon">⚠️</div>
                        <div class="item-image-text" style="color: #999;">
                            ${nanoBanana.quotaExhausted
                                ? 'API quota exhausted'
                                : 'Image generation offline'}
                        </div>
                    `;
                }
                return;
                }

                // Generate the item image
                const imageData = await nanoBanana.generateSceneImage(prompt, {
                    style: 'fantasy_art',
                aspectRatio: '1:1',  // Square for items
                itemName: itemName,
                customPrompt: customPrompt
            });

            if (loadingEl) loadingEl.style.display = 'none';

            if (imageData) {
                // Save to library with custom prompt metadata
                const imageId = nanoBanana.imageLibrary.saveImage(itemName, imageData, customPrompt);

                // Success - display the image
                if (imageEl) {
                    imageEl.src = `data:image/png;base64,${imageData}`;
                    imageEl.style.display = 'block';
                    imageEl.classList.add('loaded');
                }

                const successMsg = customPrompt
                    ? `✅ Generated custom artwork for ${itemName}! Saved to library.`
                    : `✅ Generated artwork for ${itemName}! Saved to library.`;
                addText(successMsg, 'success');
                console.log(`✅ Item image generated and saved! ID: ${imageId}, Custom: "${customPrompt}"`);
                addSystemLog(`✅ Item image saved! ID: ${imageId}`, 'success');

                // Refresh gallery
                renderImageGallery(itemName);
            } else {
                // Failed - show placeholder with error
                if (placeholderEl) {
                    placeholderEl.style.display = 'block';
                    placeholderEl.innerHTML = `
                        <div class="item-image-icon">⚠️</div>
                        <div class="item-image-text" style="color: #999;">
                            ${nanoBanana.quotaExhausted
                                ? 'API quota exhausted'
                                : 'Generation failed'}
                        </div>
                    `;
                }
            }
        }

        // ============================================================
        // IMAGE GALLERY RENDERING & INTERACTION
        // ============================================================

        /**
         * Render the image gallery for an item
         * @param {string} itemName - Name of the item
         * @param {number} page - Current page number (default 0)
         */
        function renderImageGallery(itemName, page = 0) {
            const safeItemName = itemName.replace(/\s+/g, '-');
            const images = nanoBanana.imageLibrary.getImages(itemName);
            const featuredImageObj = nanoBanana.imageLibrary.getFeaturedImage(itemName);
            const featuredId = featuredImageObj?.id;

            // Update count
            const countEl = document.getElementById(`gallery-count-${safeItemName}`);
            if (countEl) {
                countEl.textContent = `${images.length} image${images.length !== 1 ? 's' : ''}`;
            }

            // Pagination settings
            const imagesPerPage = 12;
            const totalPages = Math.ceil(images.length / imagesPerPage);
            const startIndex = page * imagesPerPage;
            const endIndex = startIndex + imagesPerPage;
            const pageImages = images.slice(startIndex, endIndex);

            // Render thumbnails
            const gridEl = document.getElementById(`gallery-grid-${safeItemName}`);
            if (gridEl) {
                if (images.length === 0) {
                    gridEl.innerHTML = '<div style="grid-column: 1/-1; text-align: center; color: #0a0; font-size: 11px; padding: 20px;">No images yet. Click "Generate New Image" to create one!</div>';
                } else {
                    gridEl.innerHTML = pageImages.map(img => {
                        const tooltip = img.customPrompt
                            ? `${img.id === featuredId ? '⭐ Featured | ' : ''}Custom: "${img.customPrompt}"`
                            : `${img.id === featuredId ? '⭐ Featured image' : 'Click to set as featured'}`;

                        return `
                            <div class="gallery-thumbnail ${img.id === featuredId ? 'featured' : ''}"
                                 onclick="setFeaturedItemImage('${itemName}', '${img.id}')"
                                 title="${tooltip}">
                                <img src="data:image/png;base64,${img.data}" alt="${itemName}">
                            </div>
                        `;
                    }).join('');
                }
            }

            // Render pagination
            const paginationEl = document.getElementById(`gallery-pagination-${safeItemName}`);
            if (paginationEl && totalPages > 1) {
                let paginationHTML = `
                    <button class="page-btn" onclick="renderImageGallery('${itemName}', ${page - 1})" ${page === 0 ? 'disabled' : ''}>◀</button>
                `;

                for (let i = 0; i < totalPages; i++) {
                    paginationHTML += `
                        <button class="page-btn ${i === page ? 'active' : ''}"
                                onclick="renderImageGallery('${itemName}', ${i})">${i + 1}</button>
                    `;
                }

                paginationHTML += `
                    <button class="page-btn" onclick="renderImageGallery('${itemName}', ${page + 1})" ${page === totalPages - 1 ? 'disabled' : ''}>▶</button>
                `;

                paginationEl.innerHTML = paginationHTML;
            } else {
                paginationEl.innerHTML = '';
            }

            // Load featured image if it exists
            const imageEl = document.getElementById(`item-generated-image-${safeItemName}`);
            const placeholderEl = document.getElementById(`item-image-placeholder-${safeItemName}`);
            if (featuredImageObj && imageEl) {
                imageEl.src = `data:image/png;base64,${featuredImageObj.data}`;
                imageEl.style.display = 'block';
                if (placeholderEl) placeholderEl.style.display = 'none';
            }
        }

        /**
         * Set an image as the featured image for an item
         * @param {string} itemName - Name of the item
         * @param {string} imageId - ID of the image to set as featured
         */
        function setFeaturedItemImage(itemName, imageId) {
            nanoBanana.imageLibrary.setFeaturedImage(itemName, imageId);

            // Update the main display
            const safeItemName = itemName.replace(/\s+/g, '-');
            const imageEl = document.getElementById(`item-generated-image-${safeItemName}`);
            const imageObj = nanoBanana.imageLibrary.getImages(itemName).find(img => img.id === imageId);

            if (imageObj && imageEl) {
                imageEl.src = `data:image/png;base64,${imageObj.data}`;
                imageEl.style.display = 'block';
            }

            // Refresh gallery to update featured indicator
            renderImageGallery(itemName);
            addText(`⭐ Set as featured image for ${itemName}`, 'success');
        }

        // ============================================================
        // END ITEM IMAGE GENERATION
        // ============================================================

        // ============================================================
        // THEME SWITCHER
        // ============================================================
        // Single source of truth for all themes
        // Add new themes here - the key is the data-theme attribute value,
        // and the value is the display name shown in the dropdown
        const THEMES = {
            blackwhite: 'Black & White',
            ultima: 'Ultima Fantasy',
            cyber: 'Cyber Terminal',
            goldbox: 'Gold Box',
            dungeon: 'Dark Dungeon'
        };

        function switchTheme(themeName) {
            document.body.dataset.theme = themeName;
            localStorage.setItem('dnd-theme', themeName);
        }

        // Load saved theme on page load
        const savedTheme = localStorage.getItem('dnd-theme') || 'blackwhite';
        document.body.dataset.theme = savedTheme;

        // Add theme dropdown to header (after page loads)
        window.addEventListener('DOMContentLoaded', async () => {
            // Initialize Nano Banana Generator
            await nanoBanana.initialize();

            const header = document.querySelector('.header');

            // Create container
            const container = document.createElement('div');
            container.className = 'theme-selector-container';

            // Create label
            const label = document.createElement('span');
            label.className = 'theme-label';
            label.textContent = 'Theme:';

            // Create dropdown
            const dropdown = document.createElement('select');
            dropdown.id = 'theme-dropdown';
            dropdown.className = 'theme-dropdown';

            // Add options from THEMES object
            Object.entries(THEMES).forEach(([themeKey, themeName]) => {
                const option = document.createElement('option');
                option.value = themeKey;
                option.textContent = themeName;
                if (themeKey === savedTheme) {
                    option.selected = true;
                }
                dropdown.appendChild(option);
            });

            // Add change event
            dropdown.onchange = (e) => {
                switchTheme(e.target.value);
            };

            // Assemble and add to header
            container.appendChild(label);
            container.appendChild(dropdown);
            header.style.position = 'relative';
            header.appendChild(container);
        });
        // ============================================================
        // END THEME SWITCHER
        // ============================================================
    </script>
</body>
</html>

